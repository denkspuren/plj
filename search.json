[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmieren lernen mit Java",
    "section": "",
    "text": "Vorwort\nDieses Buchprojekt hat seinen Z√ºndungsmoment im Wintersemester 2024/25, kurz vor Weihnachten, gefunden. Meine Studierenden aus der Veranstaltung ‚ÄúProgrammieren 1‚Äù w√ºnschten sich weitere Aufkl√§rung zur Objektorientierung.\n‚ÄúProgrammieren 1‚Äù ist der Name des Moduls, das ich f√ºr Bachelor-Studierende des Studiengangs Informatik, Ingenieurinformatik und Bioinformatik an der THM (Technische Hochschule Mittelhessen) im 1. Semester unterrichte. ‚ÄúProgrammieren 2‚Äù ist die Fortsetzung im 2. Semester. Dieses Buchprojekt m√∂chte beide Kursinhalte abdecken.\nDas Projekt ist derzeit nicht terminiert, d.h. ich habe mir kein Datum gesetzt, wann es fertig sein soll. In den Git-Repositories zu den beiden Programmierveranstaltungen hat sich sehr viel Material an Texten und Codebeispielen angesammelt. Das Material m√∂chte ich nun neu sortieren, zugeordnen und √ºberarbeiten. Schrittweise soll hier ein Kapitel nach dem anderen hinzukommen. Vielleicht muss ich gelegentlich Umstellungen vornehmen, damit es im Aufbau mehr Sinn macht. Das hier ist also Work in Progress!\nDas Schreibprojekt ist unter eine Creative Commons-Lizenz CC BY-NC-ND 4.0 gestellt. Sie d√ºrfen die Inhalte verbreiten, sie aber nicht kommerziell nutzen und nicht modifizieren. Ich empfehle ich Ihnen folgende Zitierweise:\n\nHerzberg, D.: Programmieren lernen mit Java: Eine Einf√ºhrung auf Hochschulniveau, https://denkspuren.github.io/plj/ (Zugriff: ), Lizenz: CC BY-NC-ND 4.0\n\nIch bin √ºber alle Korrekturen, Hinweise und Vorschl√§ge dankbar. Wenn Sie m√∂gen, schreiben Sie mir eine Email oder nutzen Sie die M√∂glichkeiten von GitHub, um sich einzubringen. Vielen Dank!\nHerzlichst,\nDominikus Herzberg https://www.thm.de/mni/dominikus-herzberg",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "Klassen.html",
    "href": "Klassen.html",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "1.1 Das Schema einer Klassendeklaration\nEine Klasse definiert ein Kodierschema f√ºr seine Instanzen (damit sind die Variablen, genauer Instanzvariablen gemeint) und Umgangsweisen mit dem Kodierungschema (Methoden, genauer Instanzmethoden).\nIn der Objektorientierung strebt man an, die Realisierung der Implementierung, d.h. die Details der Kodierung (die Variablen) und die Details des Umgangs mit der Kodierung (die Methoden), zu verbergen. Das geschieht in aller Regel dadurch, dass die intern gef√ºhrten Variablen private gesetzt werden und dass die Methoden keinen Einblick in den zugrundeliegenden Programmcode geben.\nDas hei√üt, anders gesagt: Mit Klassen werden zusammengesetzte Datentypen (im Javasprech ‚ÄúReferenztypen‚Äù) erstellt, wobei die Methoden die entscheidenden Abstraktionsebene sind, um mit den Instanzen einer Klasse zu arbeiten.\nDas Schema einer einfachen Klassendeklaration sieht wie folgt aus:1\nDie Reihenfolge der Deklarationen von Variablen und Methoden spielt keinerlei Rolle und kann beliebig sein.\nVariablen werden wie gewohnt deklariert nach dem Schema\nDazu kommen kann die Zuweisung eines Initialwertes\nBei Klassenvariablen wird ein static vorangestellt, z.B.:\nMethoden werden nach diesem Schema deklariert; bei Klassenmethoden wird ein static vorangestellt\nDen Parametern im Kopf einer Methode entsprechen Variablen-Deklarationen ohne initiale Zuweisung. Die Parameter werden durch ein Komma getrennt. Eine Besonderheit ist die Notation f√ºr Parameter als sogenannte Varargs. Varargs sammeln beim Aufruf der Methode beliebig viele Argumentwerte des angegebenen Typs als Array (&lt;Typ&gt;[] ParameterName) auf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#das-schema-einer-klassendeklaration",
    "href": "Klassen.html#das-schema-einer-klassendeklaration",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "class &lt;Name&gt; {\n    &lt;Deklaration von Klassenvariablen mit `static`&gt;\n    &lt;Deklaration von Instanzvariablen&gt;\n    &lt;Deklaration von Klassenmethoden mit `static`&gt;\n    &lt;Deklaration von Instanzmethoden&gt;\n}\n\n\n&lt;Typ&gt; &lt;VariablenName&gt;;\n\n&lt;Typ&gt; &lt;VariablenName&gt; = &lt;InitExpression&gt;;\n\n    static initCounter = 0;\n\n&lt;R√ºckgabetyp&gt; &lt;Methodenname&gt;(&lt;Parameter&gt;) {\n    &lt;Anweisungen&gt;\n}\n\n&lt;Typ&gt;... &lt;ParameterName&gt;",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-klasse-person-mit-instanzvariablen",
    "href": "Klassen.html#beispiel-klasse-person-mit-instanzvariablen",
    "title": "1¬† Einfache Klassen",
    "section": "1.2 Beispiel: Klasse Person mit Instanzvariablen",
    "text": "1.2 Beispiel: Klasse Person mit Instanzvariablen\nSobald eine Klasse deklariert und verbucht ist, k√∂nnen Instanzen von ihr mithilfe des new-Operators erzeugt werden. Mangels geeigneter zeichnerischer M√∂glichkeiten (Sie erinnern sich, Objekte sind ‚ÄúKreise‚Äù üòé), notieren wir den Verweis auf ein Objekt, das stets eine Instanz einer Klasse ist, wie folgt:\nObjekt := &lt;Klassenname&gt;@&lt;Identifier&gt;{ &lt;Variablenwerte&gt; }\n\nDer Klassenname entspricht dem Namen der Klasse, die beim new-Operator angegeben ist\nDer Identifier ist eine eindeutige Zahl, die sich von den Identifiern aller anderen Objekte unterscheidet.\nDer jeweilige Variablenwert verweist mit einem Pfeil -&gt; auf Referenztypen. Ist der Datenwert ein primitiver Typ, wird ein = verwendet.\nDie Darstellung der Objekte f√ºr Zeichenketten (strings) wird verk√ºrzt durch die Darstellung des Literals.\n\n\nWenn Variablen ohne Zuweisung deklariert sind, werden sie im instanziierten Objekt auf die Default-Werte gesetzt, d.h. false bei boolean, Null bei Zahlenwerten und null bei Referenztypen.\n\nclass Person {\n    int age;\n    String name;\n}\n\nPerson p1 = new Person(); // p1 -&gt; Person@1{ age = 0, name -&gt; null }\np1.name = \"Ada\";          // p1 -&gt; Person@2{ age = 0, name -&gt; \"Ada\" }\n\nPerson p2 = new Person(); // p2 -&gt; Person@2{ age = 0, name -&gt; null }\np2.name = \"Mo\";           // p2 -&gt; Person@2{ age = 0, name -&gt; \"Mo\" }\np2.age = 20;              // p2 -&gt; Person@2{ age = 20, name -&gt; \"Mo\" }\nWie man sieht, kann man mittels des Punkt-Operators (.) vom Objekt aus auf die Variablen √ºber die Variablenname zugreifen. Links vom Zuweisungs-Operator (=) entspricht dem Zugriff eine Schreiboperation, rechts davon eine Leseoperation.\nWas man hier lernt:\n\nDie Klasse Person hat genau zwei Instanzvariablen, age und name, die mit ihren Defaultwerten (Grundwerten) initialisiert werden, 0 bzw. null.\nDer new-Operator ruft den Default-Konstruktor auf. Dieser Konstruktor wird nur dann erstellt, wenn man keine Konstruktoren in der Klasse deklariert.\n\nDer unsichtbare Code des Default-Konstruktors sieht wie folgt\n    Person() {\n        super();\n    }\nDer Konstruktor ruft schlicht den Konstruktor der Oberklasse auf. Jede Klasse hat eine Oberklasse. Wenn die Oberklasse nicht explizit mit extends angegeben wird, ist es die Klasse Object.\n\nNachdem eine Instanz erzeugt ist, kann man die Werte der Instanzvariablen auslesen bzw. ihnen neue Werte zuweisen.\n\nAusprobieren:\nErg√§nzen Sie eine toString-Methode, so dass man age und name zu einer Instanz angezeigt bekommt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-person-mit-konstruktoren-und-methoden",
    "href": "Klassen.html#beispiel-person-mit-konstruktoren-und-methoden",
    "title": "1¬† Einfache Klassen",
    "section": "1.3 Beispiel: Person mit Konstruktoren und Methoden",
    "text": "1.3 Beispiel: Person mit Konstruktoren und Methoden\n\nDa das Alter (age) einer Person etwas ist, was sich mit der Zeit ver√§ndert, ist es keine so gute Idee, das Alter als Variablenwert zu modellieren. Wir √ºberarbeiten die Klasse Person.\n\n\n1.3.1 Hilfsklassen f√ºr Datumsangaben\nF√ºr die Arbeit mit Datumsangaben stellt das JDK die java.time-Bibliothek zur Verf√ºgung. F√ºr unsere Zwecke ben√∂tigen wir die Klasse LocalDate und Period, die wir zuvor importieren. Schauen Sie sich die Klassen an (die Klassenname oben sind auf die Oracle-Dokumentation verlinkt) und lesen Sie nach, wie man eine Instanz von LocalDate erzeugt und wie man aus zwei Datumsangaben einen Zeitraum Period berechnet.\n\nIm JDK gibt es viele Klassen f√ºr Standardaufgaben, deren Programmierung ausgereift ist. Zum Beispiel ist der Umgang mit Datumsangaben nicht trivial (Zeitzonen, Schaltjahre etc.). Man sucht sich heraus, was man braucht und verwendet die angebotenen Klassen mit ihren Methoden. Mit der JShell kann man rasch den Gebrauch solcher Klassen ausprobieren.\n\njshell&gt; import java.time.LocalDate;\n\njshell&gt; LocalDate.of(2024,12,16)\n$3 ==&gt; 2024-12-16\n\njshell&gt; import java.time.Period;\n\njshell&gt; Period.between($3, LocalDate.of(2026,12,16))\n$5 ==&gt; P2Y\n\njshell&gt; $5.getYears()\n$6 ==&gt; 2\nWas man hier lernt:\n\nDie toString-Methode ist in beiden Klassen angepasst, damit man wei√ü, wof√ºr das Objekt steht. P2Y ist also eine Kurzdarstellung einer Periode von 2 Jahren (years).\nDie Instanzen dieser beiden Klassen bieten einige Methoden an. Hier verwenden wir die getYears-Methode.\nLocalDate.of und Period.between sind Klassenmethoden (static methods). Woran man das erkennt? LocalDate und Period sind Klassen. W√§ren of und between Instanzmethoden, dann h√§tte man zuvor mit new ein Objekt anlegen m√ºssen. Interessanterweise wird dennoch eine Instanz der entsprechenden Klasse zur√ºckgeliefert. Wie das geht, schauen wir uns sp√§ter bei der Klasse Person an.\n\n\n\n1.3.2 Die √ºberarbeitete Klasse Person\nStatt einer Altersangabe geben wir im Konstruktor ein Geburtsdatum birth und optional (wahlweise) einen Namen name an.\nDamit niemand Zugriff auf die Variable birth hat, denn das Geburtsdatum soll nicht ver√§ndert werden k√∂nnen (auch nicht in der JShell), ist die Variable auf private gesetzt. Der Name kann auch sp√§ter nach der Geburt oder irgendwann im Leben einer Person angepasst werden. Der Zugriff auf die Variable ist nicht reglementiert.\nDas Alter wird √ºber die Methode getAge abh√§ngig von einem gegebenen Datum (oder dem aktuellen Tagesdatum) berechnet. F√ºr Zeitr√§ume die vor der Geburt liegen, wir eine ‚Äúnegative‚Äù Dauer angegeben.\nimport java.time.LocalDate;\nimport java.time.Period;\n\nclass Person {\n    private LocalDate birth;\n    String name;\n    Person(LocalDate birth, String name) {\n        this.birth = birth;\n        this.name = name;\n    }\n    Person(LocalDate birth) {\n        this(birth, \"\");\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }\n}\n\nWas man hier lernt:\n\nKonstruktoren sind eine besondere Form der Methode (Initialisierungsmethoden), die eine Instanz der Klasse zur√ºckgeben, es aber erlauben, z.B. √ºbergebene Initialisierungswerte vor der Zuweisung zu √ºberpr√ºfen (etwa mittels assert).\nMit this() kann man einen anderen Konstruktor (mit einer anderen Signatur) aufrufen. Auf diese Weise wird hier der Default-Wert (Standardwert) f√ºr name auf eine leere Zeichenkette gesetzt. (Alternativ h√§tte man String name = \"\"; deklarieren k√∂nnen.)\nDie Methode getAge ist f√ºr zwei verschiedene Signaturen deklariert. Auch hier sieht man, wie man Default-Werte setzen kann: Bei einem Aufruf ohne Argument wird das aktuelle Tagesdatum genutzt.\nDie toString-Methode passt die Repr√§sentation eines Objekts an die obige Notation an. Mit super bedient man sich der Standardrepr√§sentation der Oberklasse (stets Object bei Klassen, die keine Oberklasse mit extends angeben) und erg√§nzt mit + (String-Konkatenation, also String-Verkettung) die weiteren Angaben.\nDa die Klasse Person die Klasse Object erweitert, √ºberschreiben wir mit einer eigenen toString-Methode die der Oberklasse. Unsere lokale toString-Methode darf die Zugriffsrechte nicht reduzieren und muss deshalb ein public voranstellen.\nDas @Override ist eine sogenannte Annotation, die den Java-Compiler dazu veranlasst zu √ºberpr√ºfen, ob es in der Oberklasse eine Methode dieses Namens gibt. Wenn nicht, wird der √úbersetzungsvorgang mit einer Fehlermeldung abgebrochen. (Hinweis: Annotationen wie @Override werden in aller Regel nicht in die Methodenzeile geschrieben, sondern in einer separaten Codezeile vor dem Methodenkopf.)\nEs ist nicht notwendig, externe Klassen, die man mit import zur Nutzung bereitstellt, im Detail zu kennen und zu verstehen.\n\n\nEine getAge-Methode bedeutet nicht, dass es in der Klasse eine Variable namens age gibt ‚Äì wie das Beispiel zeigt. Es handelt sich hier nicht um eine sogenannte ‚ÄúGetter-Methode‚Äù.\n\nInteraktion:\njshell&gt; Person p1 = new Person(LocalDate.of(2000,6,1), \"Jo\")\np1 ==&gt; Person@4a87761d{ birth -&gt; 2000-06-01, name -&gt; \"Jo\" }\n\njshell&gt; p1\np1 ==&gt; Person@4a87761d{ birth -&gt; 2000-06-01, name -&gt; \"Jo\" }\n\njshell&gt; p1.name\n$39 ==&gt; \"Jo\"\n\njshell&gt; p1.birth\n|  Fehler:\n|  birth hat private-Zugriff in Person\n|  p1.birth\n|  ^------^\n\njshell&gt; p1.getAge()\n$40 ==&gt; P24Y6M15D\n\njshell&gt; p1.getAge().getYears()\n$41 ==&gt; 24\n\njshell&gt; p1.getAge(LocalDate.of(2010,7,1)).getYears()\n$42 ==&gt; 10\n\njshell&gt; p1.getAge(LocalDate.of(2010,5,1)).getYears()\n$43 ==&gt; 9\n\njshell&gt; p1.getAge(LocalDate.of(1995,5,1)).getYears()\n$44 ==&gt; -5\n\njshell&gt; p1.getAge(LocalDate.of(1995,7,1)).getYears()\n$45 ==&gt; -4\nAusprobieren:\nWas passiert, wenn man den Rumpf der toString-Methode folgenderma√üen verk√ºrzt?\n    @Override public String toString() {\n        return super.toString(); \n    }\nWas passiert, wenn man sich bei toString verschreibt (ToString)? Vergleichen Sie es mit @Override und ohne die Annotation.\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-person-mit-statischer-of-methode",
    "href": "Klassen.html#beispiel-person-mit-statischer-of-methode",
    "title": "1¬† Einfache Klassen",
    "section": "1.4 Beispiel: Person mit statischer of-Methode",
    "text": "1.4 Beispiel: Person mit statischer of-Methode\nimport java.time.LocalDate;\nimport java.time.Period;\n\nclass Person {\n    private LocalDate birth;\n    private String name = \"\";\n\n    static Person of(LocalDate birth) {\n        return new Person(birth); \n    }\n\n    private Person(LocalDate birth) {\n        LocalDate now = LocalDate.now();\n        assert birth.isBefore(now) ||\n               birth.isEqual(now) : \"Birthdate must not be in the future\"; \n        this.birth = birth;\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n    Person setName(String name) {\n        assert Objects.nonNull(name) : \"Name must not be null\";\n        name = name.trim(); // entfernt vor- und nachstehende Leerzeichen\n        assert !name.isEmpty() : \"Name must not be empty\";\n        this.name = name;\n        return this;\n    }\n    String getName() { \n        return name;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }\n}\nWas man hier lernt:\n\nNun sind die Variablen name und birth au√üerhalb der Klasse nicht einsehbar. F√ºr name sind zwei Methoden notwendig geworden: setName und getName. Allerdings, und das ist der Vorteil, wenn man Variablenwerte √ºber den Umweg von Methoden ver√§ndert, geschieht nun eine √úberpr√ºfung, ob der Name gewissen Anforderungen gen√ºgt.\nDer Konstruktor ist aufgrund von private nicht mehr von au√üerhalb der Klasse aufrufbar. Man muss jetzt Instanzen √ºber die Klassenmethode of erzeugen.\nDie Methode setName ist nicht void (was man auch h√§tte machen k√∂nnen), sondern sie gibt die eigene Person-Instanz mittels return this; zur√ºck. Das erlaubt es, Aufrufe zu verketten, siehe unten bei der Initialisierung von p2.\nSo kurz der Code auch ist, er implementiert eine eigene Logik des Umgangs mit der Idee einer ‚ÄúPerson‚Äù und kapselt sich sauber von der ‚ÄúUmwelt‚Äù ab. Eine Person kann ohne Namen erzeugt werden, allerdings darf das Geburtsdatum nicht in der Zukunft liegen. Ein sp√§ter nachgelieferter oder auch sp√§ter ge√§nderter Name kann niemals ‚Äúleer‚Äù sein, er muss aus mindestens einem Buchstaben bestehen. (Selbstredend kann man auch andere Datenlogiken als sinnvoll erachten. Das h√§ngt vom Einsatzzweck und dem Kontext ab.)\n\nInteraktion:\njshell&gt; Person p1 = Person.of(LocalDate.of(2000,12,6))\np1 ==&gt; Person@3224f60b{ birth -&gt; 2000-12-06, name -&gt; \"\" }\n\njshell&gt; p1.setName(\"Niki\")\n$10 ==&gt; Person@3224f60b{ birth -&gt; 2000-12-06, name -&gt; \"Niki\" }\n\njshell&gt; p1.getName()\n$11 ==&gt; \"Niki\"\n\njshell&gt; p1.getAge(LocalDate.of(2024,12,12))\n$12 ==&gt; P24Y6D\n\njshell&gt; Person p2 = Person.of(LocalDate.of(2000,12,6)).setName(\"Ty\")\np2 ==&gt; Person@614ddd49{ birth -&gt; 2000-12-06, name -&gt; \"Ty\" }\nFragen:\n\n\nH√§tte man f√ºr die Zusicherung in setName auch assert name != null verwenden k√∂nnen?\n\nJa, selbstverst√§ndlich. Gew√∂hnen Sie sich dennoch das sprechende Objects.nonNull(...) an. Die Klasse Objects bietet noch ein paar andere hilfreiche Methoden an.\n\n\n\nWarum beginnt der Konstruktor mit LocalDate now = LocalDate.now();? Man h√§tte die Zeile auch weglassen k√∂nnen und birth.isBefore(LocalDate.now()) und birth.isEqual(LocalDate.now()) schreiben k√∂nnen. Oder?\n\nEs ist ein √§u√üerst seltener Sonderfall: Zwischen den beiden LocalDate.now() k√∂nnte die Tagesgrenze liegen. Das w√ºrde zwar in diesem Fall keinen Schaden anrichten, aber es ist besser, mit der Variable now einen definierten Tageszeitpunkt zu w√§hlen, gegen√ºber dem die beiden Vergleiche vorgenommen werden.\n\nAusprobieren:\nVer√§ndern Sie die Methode setName auf den R√ºckgabetyp void. Was m√ºssen Sie am Code √§ndern? Was √§ndert sich an der Interaktion?",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#counter-beispiel-klassen--und-instanzmethoden-bzw.--variablen",
    "href": "Klassen.html#counter-beispiel-klassen--und-instanzmethoden-bzw.--variablen",
    "title": "1¬† Einfache Klassen",
    "section": "1.5 Counter-Beispiel: Klassen- und Instanzmethoden bzw. -Variablen",
    "text": "1.5 Counter-Beispiel: Klassen- und Instanzmethoden bzw. -Variablen\nIn einer Klassendeklaration sind Klassenvariablen von Instanzvariablen durch das Schl√ºsselwort static unterscheidbar; gleiches gilt f√ºr Klassenmethoden.\nclass Counter {\n    static int number  = 0;\n    int tick = 0;\n    static String showClass() {\n        return \"Counter{ counter = \" + number + \" }\";\n    }\n    Counter() {\n        number++;\n    }\n    Counter click() {\n        tick++;\n        return this;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ tick = \" + tick + \" }\";\n    }\n}\nWas man hier lernt:\n\nKlassenvariablen und -methoden (static) gelten nur im Kontext der Klasse. Darum m√ºssen Sie von au√üerhalb (z.B. von der JShell) √ºber den Klassennamen adressiert werden. In dem Fall also Counter.number bzw. Counter.show(). Innerhalb der Klasse ist die Erw√§hnung der Klasse nicht n√∂tig.\nInstanzvariablen und -methoden gelten nur f√ºr die Instanz. Um sich die Instanz zu erhalten, muss sie in einer Variablen gespeichert sein, z.B. in Counter c1. Dann erfolgt der Zugriff auf die Variable bzw. die Methode √ºber c1.tick bzw. c1.click().\nInnerhalb der Klasse kann eine Instanz auch √ºber das Schl√ºsselwort this auf die eigene Variable bzw. die Methode zugreifen: this.tick bzw. this.click(). Allerdings verzichtet man in aller Regel auf this, der Compiler f√ºgt das automatisch hinzu.\n\nInteraktion:\njshell&gt; Counter.number\n$3 ==&gt; 0\n\njshell&gt; Counter c1 = new Counter()\nc1 ==&gt; Counter@2f686d1f{ tick = 0 }\n\njshell&gt; Counter.number\n$5 ==&gt; 1\n\njshell&gt; Counter c2 = new Counter()\nc2 ==&gt; Counter@6e06451e{ tick = 0 }\n\njshell&gt; Counter.number\n$7 ==&gt; 2\n\njshell&gt; c1.click().click().click()\n$8 ==&gt; Counter@2f686d1f{ tick = 3 }\n\njshell&gt; c2.click()\n$9 ==&gt; Counter@6e06451e{ tick = 1 }\n\njshell&gt; Counter.number\n$10 ==&gt; 2\n\njshell&gt; c1.tick\n$11 ==&gt; 3\n\njshell&gt; c2.tick\n$12 ==&gt; 1\n\nMit Klassenvariablen und Klassenmethoden sollte man nur arbeiten, wenn der Gebrauch gut begr√ºndet ist. In der Mehrzahl der F√§lle m√∂chte man den Kontext von Instanzen nutzen, damit man von den Vorteilen der Objektorientierung profitiert.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#ausblick-record-datenklasse",
    "href": "Klassen.html#ausblick-record-datenklasse",
    "title": "1¬† Einfache Klassen",
    "section": "1.6 Ausblick: record (Datenklasse)",
    "text": "1.6 Ausblick: record (Datenklasse)\nIn modernem Java w√ºrde man die Klasse Person eher als Datenklasse (record) umsetzen. Der Code f√§llt dann k√ºrzer aus.\n\nZu Datenklassen gibt es vieles mehr zu sagen. Dieser Abschnitt soll nur zeigen, wie eine Umsetzung als Datenklasse aussieht und einer ersten Ber√ºhrung mit Datenklassen dienen.\n\nimport java.time.LocalDate;\nimport java.time.Period;\n\nrecord Person(LocalDate birth, String name) {\n    public Person {\n        assert Objects.nonNull(name) : \"Name must not be null\";\n        name = name.trim(); // entfernt vor- und nachstehende Leerzeichen\n        assert !name.isEmpty() : \"Name must not be empty\";   \n    }\n    Person(LocalDate birth) {\n        this(birth, \"\");\n    }\n    Person setName(String name) {\n        return new Person(birth, name);\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n}\n\nDie im Konstruktor angegebenen Variablen sind (1) final, d.h. unver√§nderlich (immutable) und es werden (2) f√ºr die Variablen automatisch Abrufmethoden angelegt, hier birth() und name().\nAufgrund der Immutabilit√§t (nicht √úberschreibbarkeit) von Variablen in Datenklassen, kann man auch keine Variablenwerte mehr nach dem Konstruktoraufruf √§ndern! Wenn man also den Namen mit setName anpassen m√∂chte, muss man eine neue Instanz von Person zur√ºckgeben, die das Geburtsdatum beibeh√§lt, aber mit einem neuen Namen versehen ist. Datenklassen verlangen nach einem anderen Programmierstil!\nDie √úberpr√ºfung f√ºr den Wert von name muss in den Konstruktor wandern. Grund ist wieder die Immutabilit√§t.\nDatenklassen erzeugen automatisch eine toString-Methode, die die Variablenwerte aus dem Konstruktur enth√§lt und anzeigt. Das ist in den meisten F√§llen praktisch und hilfreich.\nWenn man m√∂chte, k√∂nnte man auch hier eine Klassenmethode namens of anlegen, was bei Datenklassen aber in der Regel weniger Sinn macht.\n\nInteraktion:\njshell&gt; new Person(LocalDate.of(2000,1,1), \"Sy\")\n$25 ==&gt; Person[birth=2000-01-01, name=Sy]\n\njshell&gt; Person p = new Person(LocalDate.of(2000,1,1), \"Sy\")\np ==&gt; Person[birth=2000-01-01, name=Sy]\n\njshell&gt; p.name()\n$27 ==&gt; \"Sy\"\n\njshell&gt; p.birth()\n$28 ==&gt; 2000-01-01\n\njshell&gt; p = p.setName(\"Zu\")\np ==&gt; Person[birth=2000-01-01, name=Zu]\n\njshell&gt; p.getAge()\n$30 ==&gt; P24Y11M15D\nFragen:\n\n\nWarum hei√üt es in der Interaktion p = p.setName(\"Zu\")?\n\nWenn p eine Variable ist, die ein und die selbe Person repr√§sentieren soll, dann muss die neue Instanz von Person dem p zugewiesen werden. Grunds√§tzlich sollte die neue Instanz einer Variablen zugewiesen werden, weil ein einfaches p.setName(\"Zu\") ein nicht gespeichertes Objekt zur Folge h√§tte, was somit nicht mehr zugreifbar ist. In der JShell erfolgt die Zuweisung zu einer Variablen automatisch, damit man leichter experimentieren kann.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-stringcomposer-methoden√ºberladung-method-overloading",
    "href": "Klassen.html#beispiel-stringcomposer-methoden√ºberladung-method-overloading",
    "title": "1¬† Einfache Klassen",
    "section": "1.7 Beispiel StringComposer: Methoden√ºberladung (method overloading)",
    "text": "1.7 Beispiel StringComposer: Methoden√ºberladung (method overloading)\nDie Signatur einer Methode setzt sich zusammen aus dem Methodennamen und den Typen ihrer Parameter. Signaturen unterscheiden sich im Methodennamen und, bei gleichem Methodennamen, in der Anzahl und Reihenfolge der Typparameter. Ausdr√ºcklich nicht zur Signatur z√§hlen der R√ºckgabetyp einer Methode, Ausnahmen (die kann man im Methodenkopf angeben) und die Parameternamen.\nGibt es zu einem Methodennamen mehrere unterschiedliche Signaturen, spricht man von Methoden√ºberladung. Das meint: Man kann die Methode unter ihrem Namen mit unterschiedlichen Argumenttypen und/oder einer unterschiedlichen Anzahl von Argumenten aufrufen.\nDas nachstehende Beispiel zeigt die Methoden√ºberladung f√ºr die Methode append. Die Signaturen unterscheiden sich eindeutig (sonst w√ºrde der Compiler einen Fehler melden), so dass beim Methodenaufruf stets die passende Methode ausgew√§hlt wird.\nclass StringComposer {\n    String s;\n    StringComposer(String s) { this.s = s; }\n    String append(int n) { return s += n; }\n    String append(String text) { return s += text; }\n    String append(String text, int times) {\n        for (int i = 1; i &lt;= times; ++i) s += text;\n        return s;\n    }\n    String append(int n, int times) { return append(\"\" + n, times); }\n    String append(String... texts) {\n        for (String text : texts) s += text;\n        return s;\n    }\n    String append(String a, String b) {\n        return s += a + b;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ s -&gt; \\\"\" + s + \"\\\" }\";\n    }\n}\nWas man hier lernt\n\nDie Signaturen lauten append(int), append(String), append(String, int) usw. Sie m√ºssen alle unterschiedlich sein. Man sagt: Die Methode append ist √ºberladen. (Im Beispiel sind alle R√ºckgabetypen gleich. Das m√ºsste nicht so sein.)\nBeim Aufruf wird die spezifischste Methode gew√§hlt. Bei einer bzw. zwei Zeichenketten im Aufruf, werden die Methoden mit den Signaturen append(String) bzw. append(String, String) gew√§hlt. Bei keiner, drei oder mehr Zeichenketten greift append(String...).\nEine Zuweisung wie z.B. s += text ver√§ndert nicht nur eine Variable, sie gibt zudem den Zuweisungswert zur√ºck. Das erlaubt neben der Zuweisung eine R√ºckgabe des Werts mittels return.\n\nInteraktion\njshell&gt; StringComposer sc = new StringComposer(\"Hi\")\nsc ==&gt; StringComposer@6500df86{ s -&gt; \"Hi\" }\n\njshell&gt; sc.append(3)\n$3 ==&gt; \"Hi3\"\n\njshell&gt; sc.append(\"You\")\n$4 ==&gt; \"Hi3You\"\n\njshell&gt; sc.append(\"c\", 3)\n$5 ==&gt; \"Hi3Youccc\"\n\njshell&gt; sc.append(5, 3)\n$6 ==&gt; \"Hi3Youccc555\"\n\njshell&gt; sc.append(\"a\", \"b\")\n$7 ==&gt; \"Hi3Youccc555ab\"\n\njshell&gt; sc.append(\"a\", \"b\", \"c\", \"d\")\n$8 ==&gt; \"Hi3Youccc555ababcd\"\n\njshell&gt; sc.append()\n$9 ==&gt; \"Hi3Youccc555ababcd\"\n\njshell&gt; sc\nsc ==&gt; StringComposer@6500df86{ s -&gt; \"Hi3Youccc555ababcd\" }\nAusprobieren\nVer√§ndern Sie den R√ºckgabewert einer append-Methode in void. √Ñndert das etwas an der Methoden√ºberladung?\nSind Sie sicher, dass sc.append(\"a\", \"b\") nicht die Methoden mit der Signatur append(String...) aufruft? Ver√§ndern Sie den Code in den Methodenr√ºmpfen so, dass unterscheidbar ist, welche Methode aufgerufen wird. (Im Zweifel d√ºrfen Sie ausnahmsweise System.out.println verwenden.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#counter-initiale-codebl√∂cke-static-...-und-...",
    "href": "Klassen.html#counter-initiale-codebl√∂cke-static-...-und-...",
    "title": "1¬† Einfache Klassen",
    "section": "1.8 Counter: Initiale Codebl√∂cke static { ... } und { ... }",
    "text": "1.8 Counter: Initiale Codebl√∂cke static { ... } und { ... }\nDas obige Schema f√ºr eine Klassendeklaration hat zwei initiale Codebl√∂cke unterschlagen, die in einer Klassendeklaration vorkommen k√∂nnen.\nclass &lt;Name&gt; {\n    static { /* Klasseninitialisierung */ }\n    { /* Instanzinitialisierung */ }\n    &lt;Deklaration von Klassenvariablen mit `static`&gt;\n    &lt;Deklaration von Instanzvariablen&gt;\n    &lt;Deklaration von Klassenmethoden mit `static`&gt;\n    &lt;Deklaration von Instanzmethoden&gt;\n}\nMan kann in einer Klassendeklaration einen statischen Block static { ... } einf√ºgen, der zur Ladezeit der Klasse ausgef√ºhrt wird, und einen Block { ... }, der beim Instanziieren von Objekten zur Ausf√ºhrung kommt.\nNehmen wir die Klasse Counter und f√ºgen in den Initialisierungbl√∂cken println-Anweisungen ein zur Nachvollziehbarkeit des Zeitpunkts der Ausf√ºhrung des Blocks.\nclass Counter {\n    static int number  = 0;\n    int tick = 0;\n    static {\n        System.out.println(\"Executed at class loading time\");\n    }\n    { \n        System.out.println(\"Executed prior to constructor call\");\n    }\n    static String showClass() {\n        return \"Counter{ counter = \" + number + \" }\";\n    }\n    Counter() {\n        number++;\n    }\n    Counter click() {\n        tick++;\n        return this;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ tick = \" + tick + \" }\";\n    }\n}\nKopiert man den Code in die JShell und erzeugt eine erste Instanz, sieht man deutlich den Effekt der Bl√∂cke. Der statische Init-Block (Klasseninitialisierung) wird nur ein einziges Mal aufgerufen, der andere Init-Block (Instanzinitialisierung) wird bei jeder Instanziierung aufgerufen und zwar vor der Abarbeitung des Codes im Konstuktor.\nInteraktion\njshell&gt; new Counter()\nExecuted at class loading time\nExecuted prior to constructor call\n$2 ==&gt; Counter@2f686d1f{ tick = 0 }\n\njshell&gt; new Counter()\nExecuted prior to constructor call\n$3 ==&gt; Counter@6e06451e{ tick = 0 }\n\njshell&gt; new Counter()\nExecuted prior to constructor call\n$4 ==&gt; Counter@6e1567f1{ tick = 0 }\n\nMan sollte den Block f√ºr die Instanzinitialisierung nicht als Ersatz f√ºr einen Konstruktor nehmen und auf seinen Gebrauch verzichten. Gleiches gilt f√ºr den Block zur Klasseninitialisierung. Man sollte also wissen, dass es diese Bl√∂cke gibt, sie aber nur dann einsetzen, wenn es sehr gute Gr√ºnde daf√ºr gibt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#gratis-methoden-von-object",
    "href": "Klassen.html#gratis-methoden-von-object",
    "title": "1¬† Einfache Klassen",
    "section": "1.9 ‚ÄúGratis‚Äù-Methoden von Object",
    "text": "1.9 ‚ÄúGratis‚Äù-Methoden von Object\nKlassen, die ohne ein explizites extends im Kopf der Deklaration auskommen, haben ein implizites extends Object da stehen. Die Klassen dieses Kapitels kann man also gedanklich im Deklarationskopf lesen als:\nclass Person extends Object { /* body */ }\n\nclass Counter extends Object { /* body */ }\n\nclass StringComposer extends Object { /* body */ }\nJede ‚Äúeinfache‚Äù Klasse erweitert die Klasse Object. Das hat zur Folge, dass jede Klasse die folgenden Methoden von Object √ºbernimmt oder ausdr√ºcklich mit einer eigenen Implementierung √ºberschreibt:\n\nprotected Object clone()\n\nErzeugt eine Kopie des Objekts\n\npublic boolean equals(Object other)\n\nObjekte vergleicht man in aller Regel nicht mit dem Gleichheitsoperator == (es sei denn, man m√∂chte die Identit√§t, d.h. die Referenzgleichheit der Objekte √ºberpr√ºfen), sondern mit Hilfe der equals-Methode, die es erlaubt, die inhaltliche Gleichheit von Objekten anhand ihrer Datenwerte zu √ºberpr√ºfen. Allerdings muss man diese Methode √ºberschreiben und mit einer passenden Implementierung ersetzen. Mehr dazu in einem gesonderten Abschnitt.  Die Standard-Implementierung in Object sieht wie folgt aus:\n\n\n    public boolean equals(Object other) {\n        return this == other;\n    }\n\npublic final Class&lt;?&gt; getClass()\n\nLiefert die Laufzeit-Repr√§sentation der Klasse des Objekts.\n\npublic int hashCode()\n\nGibt den HashCode eines Objekts zur√ºck. Der HashCode f√ºr ein Objekt wird ben√∂tigt f√ºr Datenstrukturen wie z.B. die HashMap. Zwei Objekte die gleich sind, m√ºssen den gleichen HashCode haben.\n\npublic String toString()\n\nLiefert eine Repr√§sentation, d.h. eine textuelle Selbstdarstellung des Objekts zur√ºck. Die Standards-Implementierung von Object sieht (geringf√ºgig vereinfacht) wie folgt aus:\n\n\n    public String toString() {\n        return getClass().getName() + \"@\" + \n               Integer.toHexString(hashCode());\n    }\nDie noch verbleibenden Methoden notify(), notifyAll() und die √ºberladene Methode wait(...) sind relevant f√ºr die nebenl√§ufige Programmierung mit Threads. Das wollen wir an dieser Stelle vorerst √ºbergehen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#was-genau-ist-ein-objekt",
    "href": "Klassen.html#was-genau-ist-ein-objekt",
    "title": "1¬† Einfache Klassen",
    "section": "1.10 Was genau ist ein Objekt?",
    "text": "1.10 Was genau ist ein Objekt?\nTechnisch gesprochen belegt ein Objekt einen Speicherbereich in einem Speicher, der sich Heap (engl. f√ºr ‚ÄúHaufen‚Äù) nennt. Der Heap ist ein verwalteter Speicherbereich. Die Speicherverwaltung schafft Platz f√ºr neu dazukommende Objekte, reorganisiert gelegentlich den Speicher (z.B. wenn es zu viele L√ºcken gibt, so dass neue Objekte Platz finden) und k√ºmmert sich darum, dass Objekte, die direkt oder indirekt durch die aktiven Referenzen nicht mehr erreicht werden, aus dem Heap entfernt werden; dies nennt sich Garbage Collection (GC, Speicherbereinigung).\nWenn in Java der new-Operator zum Einsatz kommt, wird ein Objekt erzeugt. Nehmen wir den obigen Code zur Klasse Person zur Anschauung (die Variante mit der of-Methode):\njshell&gt; Person p = Person.of(LocalDate.of(2000,1,1)).setName(\"Jes\")\np ==&gt; Person@5ce81285{ birth -&gt; 2000-01-01, name -&gt; \"Jes\" }\nZum Anlegen des Objektes werden in der Klasse Person lediglich die Instanzvariablen (die ‚Äúnormalen‚Äù und nicht als static ausgewiesenen Variablendeklarationen) betrachtet. Entsprechend der dortigen Typangaben wird der ben√∂tigte Speicherplatz f√ºr die Variablen bereitgestellt. Auf dem Heap kommt das Objekt mit folgendem Speicheraufbau unter einer dynamisch vergebenen Speicheradresse zum Tragen:\n\nSpeicherorganisation eines Objekts, das eine Instanz von Person ist\n\n\nOffset\nBytes\nFeld\nBeschreibung\n\n\n\n\n0\n8\nMark Word\nMetadaten: HashCode, Synchronisation, GC\n\n\n8\n8\nClass Pointer\nVerweis auf die Klassenbeschreibung\n\n\n16\n4\nbirth\nReferenz auf LocalDate-Instanz\n\n\n20\n4\nname\nReferenz auf String-Instanz\n\n\n24\n8\nPadding\nAuff√ºll-Bytes f√ºr Gesamtgr√∂√üe von 32 Bytes\n\n\n\nOhne hier auf alle Details einzugehen: Neben der Speicheradresse (dem entspricht die Referenz) f√ºr diesen Speicherblock, weist die Tabelle die entscheidenden und wichtigen Infos aus: Den HashCode (sofern er nicht √ºber eine √ºberschriebene hashCode-Methode berechnet wird), den Verweis auf die Klasse, von der das Objekt instanziiert wird (erh√§ltlich √ºber getClass()), und die Speicherbedarfe f√ºr die Instanzvariablen, hier Referenzen auf die Objekte von den Klassen LocalDate und String.\nDie Variable p im obigen Beispiel enth√§lt also die Referenz auf ein Objekt, das eine Instanz der Klasse Person ist. Der Referenz entspricht die Speicheradresse, an der der Speicherblock f√ºr das Objekt beginnt. Die Speicheradresse ist nicht einsehbar, sie wird aber intern herangezogen, wenn zwei Objekte auf Gleichheit mit dem Operator == gepr√ºft werden.\nAls Mensch helfen die technischen Einblicke f√ºr das Verst√§ndnis, aber Bilder sind besser, um einen Gesamtblick zu bekommen. Man kann Referenzen sehr gut als Pfeile (= Verweise) auf Objekte verstehen, wobei der Name am Pfeil den Variablennamen kennzeichnet. Objekte sind in dem nachstehenden Bild als K√§sten mit abgerundeten Ecken dargestellt. In dem Objekt steht entweder der Name der Klasse, von der das Objekt instanziiert wurde, oder seine Repr√§sentation, wie sie durch die toString-Methode bestimmt ist.\n\n\n\nEine Instanz von Person",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#footnotes",
    "href": "Klassen.html#footnotes",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "Ich unterschlage hier, dass in dem Schema zwei Arten von Initialisierungsbl√∂cken vorkommen: der Block static { ... }, der zur Ladezeit der Klasse ausgef√ºhrt wird, und der Block { ... }, der beim Instanziieren von Objekten ausgef√ºhrt wird.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "legal/impressum.html",
    "href": "legal/impressum.html",
    "title": "Impressum",
    "section": "",
    "text": "Prof.¬†Dr.¬†Dr.¬†Dominikus Herzberg Technische Hochschule Mittelhessen Fachbereich Mathematik, Naturwissenschaften und Informatik Wiesenstra√üe 14 35390 Gie√üen\nKontakt:\nTelefon: +49 (0)641 309 2300 Telefax: +49 (0)641 309 2908 E-Mail: dominikus.herzberg at mni dot thm dot de Website: https://www.thm.de/mni/dominikus-herzberg"
  },
  {
    "objectID": "legal/datenschutz.html",
    "href": "legal/datenschutz.html",
    "title": "Datenschutzerkl√§rung",
    "section": "",
    "text": "Verantwortliche Stelle\nIm folgenden m√∂chten wir Sie aufkl√§ren, wie Ihre Daten von uns verarbeitet werden.\nVerantwortlich im Sinne der DSGVO ist:\nProf.¬†Dr.¬†Dr.¬†Dominikus Herzberg Technische Hochschule Mittelhessen Fachbereich Mathematik, Naturwissenschaften und Informatik Wiesenstra√üe 14 35390 Gie√üen\nTelefon: +49 (0)641 309 2300 E-Mail: dominikus.herzberg at mni dot thm dot de\nSollten Sie per E-Mail mit uns Kontakt aufnehmen, werden die mitgeteilten Daten von uns gespeichert, um Ihr Anliegen zu bearbeiten.\nZu den verarbeiteten Daten z√§hlen:\nWir werden die Daten l√∂schen, sobald die Speicherung nicht mehr erforderlich ist oder die Verarbeitung einschr√§nken, falls gesetzliche Aufbewahrungspflichten bestehen."
  },
  {
    "objectID": "legal/datenschutz.html#verantwortliche-stelle",
    "href": "legal/datenschutz.html#verantwortliche-stelle",
    "title": "Datenschutzerkl√§rung",
    "section": "",
    "text": "Ihr Name\nIhre E-Mail-Adresse"
  },
  {
    "objectID": "legal/datenschutz.html#hosting",
    "href": "legal/datenschutz.html#hosting",
    "title": "Datenschutzerkl√§rung",
    "section": "Hosting",
    "text": "Hosting\nUnser Hoster erhebt in sogenannte Logfiles folgende Daten, die dein Browser √ºbermittelt:\nIP-Adresse, die Adresse der vorher besuchten Website (Referer Anfrage-Header), Datum und Uhrzeit der Anfrage, Zeitzonendifferenz zur Greenwich Mean Time, Inhalt der Anforderung, HTTP-Statuscode, √ºbertragene Datenmenge, Website, von der die Anforderung kommt und Informationen zu Browser und Betriebssystem.\nDas ist erforderlich, um unsere Website anzuzeigen und die Stabilit√§t und Sicherheit zu gew√§hrleisten. Dies entspricht unserem berechtigten Interesse im Sinne des Art. 6 Abs. 1 S. 1 lit. f DSGVO.\nEs erfolgt kein Tracking und wir haben auf diese Daten keinen direkten Zugriff, sondern erhalten lediglich eine anonymisierte, statistische Zusammenfassung. Diese beinhaltet die Adresse der vorher besuchten Seite, die H√§ufigkeit der jeweils aufgerufenen Seiten und die Anzahl eindeutiger Besucher. Diese Daten f√ºhren wir nicht mit anderen Daten zusammen.\nWir setzen f√ºr die Zurverf√ºgungstellung unserer Website folgenden Hoster ein:\nGitHub Inc. 88 Colin P Kelly Jr St San Francisco, CA 94107 United States\nDieser ist Empf√§nger deiner personenbezogenen Daten. Dies entspricht unserem berechtigten Interesse im Sinne des Art. 6 Abs. 1 S. 1 lit. f DSGVO, selbst keinen Server in unseren R√§umlichkeiten vorhalten zu m√ºssen. Serverstandort ist USA.\nWeitere Informationen zu Widerspruchs- und Beseitigungsm√∂glichkeiten gegen√ºber GitHub findest du unter: https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-privacy-statement#github-pages\nDu hast das Recht der Verarbeitung zu widersprechen. Ob der Widerspruch erfolgreich ist, ist im Rahmen einer Interessenabw√§gung zu ermitteln.\nDie Daten werden gel√∂scht, sobald der Zweck der Verarbeitung entf√§llt.\nDie Verarbeitung der unter diesem Abschnitt angegebenen Daten ist weder gesetzlich noch vertraglich vorgeschrieben. Die Funktionsf√§higkeit der Website ist ohne die Verarbeitung nicht gew√§hrleistet.\nGitHub hat Compliance-Ma√ünahmen f√ºr internationale Daten√ºbermittlungen umgesetzt. Diese gelten f√ºr alle weltweiten Aktivit√§ten, bei denen GitHub personenbezogene Daten von nat√ºrlichen Personen in der EU verarbeitet. Diese Ma√ünahmen basieren auf den EU-Standardvertragsklauseln (SCCs). Weitere Informationen findest du unter: https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-data-protection-addendum#attachment-1‚Äìthe-standard-contractual-clauses-processors"
  },
  {
    "objectID": "legal/datenschutz.html#betroffenenrechte-und-hinweise",
    "href": "legal/datenschutz.html#betroffenenrechte-und-hinweise",
    "title": "Datenschutzerkl√§rung",
    "section": "Betroffenenrechte und Hinweise",
    "text": "Betroffenenrechte und Hinweise\nAls betroffene Person haben Sie folgende Rechte nach der DSGVO:\n\nAuskunft (Art. 15 DSGVO) ‚Äì Sie k√∂nnen jederzeit eine Best√§tigung verlangen, ob personenbezogene Daten √ºber Sie verarbeitet werden.\nBerichtigung (Art. 16 DSGVO) ‚Äì Sie haben das Recht auf Berichtigung unrichtiger oder unvollst√§ndiger personenbezogener Daten.\nL√∂schung (Art. 17 DSGVO) ‚Äì Sie haben das Recht, die L√∂schung Ihrer Daten zu verlangen, wenn diese nicht mehr ben√∂tigt werden oder unrechtm√§√üig verarbeitet werden.\nEinschr√§nkung der Verarbeitung (Art. 18 DSGVO) ‚Äì Sie k√∂nnen in bestimmten F√§llen die Einschr√§nkung der Verarbeitung Ihrer personenbezogenen Daten verlangen.\nWiderspruch (Art. 21 DSGVO) ‚Äì Sie k√∂nnen der Verarbeitung Ihrer personenbezogenen Daten widersprechen, sofern sich die Verarbeitung auf ein berechtigtes Interesse st√ºtzt.\nDaten√ºbertragbarkeit (Art. 20 DSGVO) ‚Äì Sie haben das Recht, die von Ihnen bereitgestellten Daten in einem strukturierten, g√§ngigen und maschinenlesbaren Format zu erhalten.\nWiderruf der Einwilligung (Art. 21 DSGVO) ‚Äì Sie k√∂nnen die Einwilligung zur Verarbeitung Ihrer Daten jederzeit widerrufen.\nBeschwerderecht ‚Äì Sie haben das Recht, sich bei einer Aufsichtsbeh√∂rde √ºber die Verarbeitung zu beschweren. Eine Liste der entsprechenden Beh√∂rden finden Sie unter: https://www.bfdi.bund.de/DE/Infothek/Anschriften_Links/anschriften_links-node.html.\n\nHinweisen m√∂chten wir Sie zudem auf Folgendes:\n\nPflicht zur Bereitstellung von Daten ‚Äì Die Bereitstellung personenbezogener Daten ist zur Nutzung dieser Webseite nicht erforderlich. Sie m√ºssen keine personenbezogenen Daten angeben, um die Seite zu besuchen. Es ist jedoch m√∂glich, dass einige Daten (wie Server-Logs) automatisch erfasst werden, wenn Sie die Webseite besuchen.\nAutomatisierte Entscheidungsfindung/Profiling ‚Äì Auf dieser Webseite werden keine automatisierten Entscheidungen oder Profiling-Ma√ünahmen durchgef√ºhrt.\nVerweise auf externe Webseiten ‚Äì Diese Webseite enth√§lt Links zu externen Webseiten, auf deren Inhalt und Datenschutzpraktiken wir keinen Einfluss haben. F√ºr den Inhalt der verlinkten Seiten sind ausschlie√ülich deren Betreiber verantwortlich. Bitte beachten Sie, dass beim Anklicken eines externen Links personenbezogene Daten (wie Ihre IP-Adresse) an den Betreiber der externen Webseite √ºbermittelt werden k√∂nnen. Wir empfehlen, die Datenschutzerkl√§rungen der verlinkten Webseiten zu pr√ºfen."
  },
  {
    "objectID": "legal/datenschutz.html#einsatz-von-google-fonts",
    "href": "legal/datenschutz.html#einsatz-von-google-fonts",
    "title": "Datenschutzerkl√§rung",
    "section": "Einsatz von Google Fonts",
    "text": "Einsatz von Google Fonts\nDiese Seite nutzt zur einheitlichen Darstellung von Schriftarten so genannte Google Fonts, die von Google bereitgestellt werden. Beim Aufruf einer Seite l√§dt Ihr Browser die ben√∂tigten Fonts in ihren Browsercache, um Texte und Schriftarten korrekt anzuzeigen.\nZu diesem Zweck muss der von Ihnen verwendete Browser Verbindung zu den Servern von Google aufnehmen. Hierdurch erlangt Google Kenntnis dar√ºber, dass √ºber Ihre IP-Adresse diese Website aufgerufen wurde. Die Nutzung von Google Fonts erfolgt auf Grundlage von Art. 6 Abs. 1 lit. f DSGVO. Der Websitebetreiber hat ein berechtigtes Interesse an der einheitlichen Darstellung des Schriftbildes auf seiner Website. Sofern eine entsprechende Einwilligung abgefragt wurde, erfolgt die Verarbeitung ausschlie√ülich auf Grundlage von Art. 6 Abs. 1 lit. a DSGVO und ¬ß 25 Abs. 1 TDDDG, soweit die Einwilligung die Speicherung von Cookies oder den Zugriff auf Informationen im Endger√§t des Nutzers (z.B. Device-Fingerprinting) im Sinne des TDDDG umfasst. Die Einwilligung ist jederzeit widerrufbar.\nWenn Ihr Browser Google Fonts nicht unterst√ºtzt, wird eine Standardschrift von Ihrem Computer genutzt. Weitere Informationen zu Google Fonts finden Sie unter https://developers.google.com/fonts/faq und in der Datenschutzerkl√§rung von Google: https://policies.google.com/privacy?hl=de.\nDas Unternehmen verf√ºgt √ºber eine Zertifizierung nach dem ‚ÄûEU-US Data Privacy Framework‚Äú (DPF). Der DPF ist ein √úbereinkommen zwischen der Europ√§ischen Union und den USA, der die Einhaltung europ√§ischer Datenschutzstandards bei Datenverarbeitungen in den USA gew√§hrleisten soll. Jedes nach dem DPF zertifizierte Unternehmen verpflichtet sich, diese Datenschutzstandards einzuhalten. Weitere Informationen hierzu erhalten Sie vom Anbieter unter folgendem Link: https://www.dataprivacyframework.gov/participant/5780."
  }
]