[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmieren lernen mit Java",
    "section": "",
    "text": "Vorwort\nDieses Buchprojekt hat seinen Z√ºndungsmoment im Wintersemester 2024/25, kurz vor Weihnachten, gefunden. Meine Studierenden aus der Veranstaltung ‚ÄúProgrammieren 1‚Äù w√ºnschten sich weitere Aufkl√§rung zur Objektorientierung.\n‚ÄúProgrammieren 1‚Äù ist der Name des Moduls, das ich f√ºr Bachelor-Studierende des Studiengangs Informatik, Ingenieurinformatik und Bioinformatik an der THM (Technische Hochschule Mittelhessen) im 1. Semester unterrichte. ‚ÄúProgrammieren 2‚Äù ist die Fortsetzung im 2. Semester. Dieses Buchprojekt m√∂chte beide Kursinhalte abdecken.\nDas Projekt ist derzeit nicht terminiert, d.h. ich habe mir kein Datum gesetzt, wann es fertig sein soll. In den Git-Repositories zu den beiden Programmierveranstaltungen hat sich sehr viel Material an Texten und Codebeispielen angesammelt. Das Material m√∂chte ich nun neu sortieren, zugeordnen und √ºberarbeiten. Schrittweise soll hier ein Kapitel nach dem anderen hinzukommen. Vielleicht muss ich gelegentlich Umstellungen vornehmen, damit es im Aufbau mehr Sinn macht. Das hier ist also Work in Progress!\nDas Schreibprojekt ist unter eine Creative Commons-Lizenz CC BY-NC-ND 4.0 gestellt. Sie d√ºrfen die Inhalte verbreiten, sie aber nicht kommerziell nutzen und nicht modifizieren. Ich empfehle ich Ihnen folgende Zitierweise:\n\nHerzberg, D.: Programmieren lernen mit Java: Eine Einf√ºhrung auf Hochschulniveau, https://denkspuren.github.io/plj/ (Zugriff: ), Lizenz: CC BY-NC-ND 4.0\n\nIch bin √ºber alle Korrekturen, Hinweise und Vorschl√§ge dankbar. Wenn Sie m√∂gen, schreiben Sie mir eine Email oder nutzen Sie die M√∂glichkeiten von GitHub, um sich einzubringen. Vielen Dank!\nHerzlichst,\nDominikus Herzberg https://www.thm.de/mni/dominikus-herzberg",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "Klassen.html",
    "href": "Klassen.html",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "1.1 Das Schema einer Klassendeklaration\nEine Klasse definiert ein Kodierschema f√ºr seine Instanzen (damit sind die Variablen, genauer Instanzvariablen gemeint) und Umgangsweisen mit dem Kodierungschema (Methoden, genauer Instanzmethoden).\nIn der Objektorientierung strebt man an, die Realisierung der Implementierung, d.h. die Details der Kodierung (die Variablen) und die Details des Umgangs mit der Kodierung (die Methoden), zu verbergen. Das geschieht in aller Regel dadurch, dass die intern gef√ºhrten Variablen private gesetzt werden und dass die Methoden keinen Einblick in den zugrundeliegenden Programmcode geben.\nDas hei√üt, anders gesagt: Mit Klassen werden zusammengesetzte Datentypen (im Javasprech ‚ÄúReferenztypen‚Äù) erstellt, wobei die Methoden die entscheidenden Abstraktionsebene sind, um mit den Instanzen einer Klasse zu arbeiten.\nDas Schema einer einfachen Klassendeklaration sieht wie folgt aus:1\nDie Reihenfolge der Deklarationen von Variablen und Methoden spielt keinerlei Rolle und kann beliebig sein.\nVariablen werden wie gewohnt deklariert nach dem Schema\nDazu kommen kann die Zuweisung eines Initialwertes\nBei Klassenvariablen wird ein static vorangestellt, z.B.:\nMethoden werden nach diesem Schema deklariert; bei Klassenmethoden wird ein static vorangestellt\nDen Parametern im Kopf einer Methode entsprechen Variablen-Deklarationen ohne initiale Zuweisung. Die Parameter werden durch ein Komma getrennt. Eine Besonderheit ist die Notation f√ºr Parameter als sogenannte Varargs. Varargs sammeln beim Aufruf der Methode beliebig viele Argumentwerte des angegebenen Typs als Array (&lt;Typ&gt;[] ParameterName) auf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#das-schema-einer-klassendeklaration",
    "href": "Klassen.html#das-schema-einer-klassendeklaration",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "class &lt;Name&gt; {\n    &lt;Deklaration von Klassenvariablen mit `static`&gt;\n    &lt;Deklaration von Instanzvariablen&gt;\n    &lt;Deklaration von Klassenmethoden mit `static`&gt;\n    &lt;Deklaration von Instanzmethoden&gt;\n}\n\n\n&lt;Typ&gt; &lt;VariablenName&gt;;\n\n&lt;Typ&gt; &lt;VariablenName&gt; = &lt;InitExpression&gt;;\n\n    static initCounter = 0;\n\n&lt;R√ºckgabetyp&gt; &lt;Methodenname&gt;(&lt;Parameter&gt;) {\n    &lt;Anweisungen&gt;\n}\n\n&lt;Typ&gt;... &lt;ParameterName&gt;",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-klasse-person-mit-instanzvariablen",
    "href": "Klassen.html#beispiel-klasse-person-mit-instanzvariablen",
    "title": "1¬† Einfache Klassen",
    "section": "1.2 Beispiel: Klasse Person mit Instanzvariablen",
    "text": "1.2 Beispiel: Klasse Person mit Instanzvariablen\nSobald eine Klasse deklariert und verbucht ist, k√∂nnen Instanzen von ihr mithilfe des new-Operators erzeugt werden. Mangels geeigneter zeichnerischer M√∂glichkeiten (Sie erinnern sich, Objekte sind ‚ÄúKreise‚Äù üòé), notieren wir den Verweis auf ein Objekt, das stets eine Instanz einer Klasse ist, wie folgt:\nObjekt := &lt;Klassenname&gt;@&lt;Identifier&gt;{ &lt;Variablenwerte&gt; }\n\nDer Klassenname entspricht dem Namen der Klasse, die beim new-Operator angegeben ist\nDer Identifier ist eine eindeutige Zahl, die sich von den Identifiern aller anderen Objekte unterscheidet.\nDer jeweilige Variablenwert verweist mit einem Pfeil -&gt; auf Referenztypen. Ist der Datenwert ein primitiver Typ, wird ein = verwendet.\nDie Darstellung der Objekte f√ºr Zeichenketten (strings) wird verk√ºrzt durch die Darstellung des Literals.\n\n\nWenn Variablen ohne Zuweisung deklariert sind, werden sie im instanziierten Objekt auf die Default-Werte gesetzt, d.h. false bei boolean, Null bei Zahlenwerten und null bei Referenztypen.\n\nclass Person {\n    int age;\n    String name;\n}\n\nPerson p1 = new Person(); // p1 -&gt; Person@1{ age = 0, name -&gt; null }\np1.name = \"Ada\";          // p1 -&gt; Person@2{ age = 0, name -&gt; \"Ada\" }\n\nPerson p2 = new Person(); // p2 -&gt; Person@2{ age = 0, name -&gt; null }\np2.name = \"Mo\";           // p2 -&gt; Person@2{ age = 0, name -&gt; \"Mo\" }\np2.age = 20;              // p2 -&gt; Person@2{ age = 20, name -&gt; \"Mo\" }\nWie man sieht, kann man mittels des Punkt-Operators (.) vom Objekt aus auf die Variablen √ºber die Variablenname zugreifen. Links vom Zuweisungs-Operator (=) entspricht dem Zugriff eine Schreiboperation, rechts davon eine Leseoperation.\nWas man hier lernt:\n\nDie Klasse Person hat genau zwei Instanzvariablen, age und name, die mit ihren Defaultwerten (Grundwerten) initialisiert werden, 0 bzw. null.\nDer new-Operator ruft den Default-Konstruktor auf. Dieser Konstruktor wird nur dann erstellt, wenn man keine Konstruktoren in der Klasse deklariert.\n\nDer unsichtbare Code des Default-Konstruktors sieht wie folgt\n    Person() {\n        super();\n    }\nDer Konstruktor ruft schlicht den Konstruktor der Oberklasse auf. Jede Klasse hat eine Oberklasse. Wenn die Oberklasse nicht explizit mit extends angegeben wird, ist es die Klasse Object.\n\nNachdem eine Instanz erzeugt ist, kann man die Werte der Instanzvariablen auslesen bzw. ihnen neue Werte zuweisen.\n\nAusprobieren:\nErg√§nzen Sie eine toString-Methode, so dass man age und name zu einer Instanz angezeigt bekommt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-person-mit-konstruktoren-und-methoden",
    "href": "Klassen.html#beispiel-person-mit-konstruktoren-und-methoden",
    "title": "1¬† Einfache Klassen",
    "section": "1.3 Beispiel: Person mit Konstruktoren und Methoden",
    "text": "1.3 Beispiel: Person mit Konstruktoren und Methoden\n\nDa das Alter (age) einer Person etwas ist, was sich mit der Zeit ver√§ndert, ist es keine so gute Idee, das Alter als Variablenwert zu modellieren. Wir √ºberarbeiten die Klasse Person.\n\n\n1.3.1 Hilfsklassen f√ºr Datumsangaben\nF√ºr die Arbeit mit Datumsangaben stellt das JDK die java.time-Bibliothek zur Verf√ºgung. F√ºr unsere Zwecke ben√∂tigen wir die Klasse LocalDate und Period, die wir zuvor importieren. Schauen Sie sich die Klassen an (die Klassenname oben sind auf die Oracle-Dokumentation verlinkt) und lesen Sie nach, wie man eine Instanz von LocalDate erzeugt und wie man aus zwei Datumsangaben einen Zeitraum Period berechnet.\n\nIm JDK gibt es viele Klassen f√ºr Standardaufgaben, deren Programmierung ausgereift ist. Zum Beispiel ist der Umgang mit Datumsangaben nicht trivial (Zeitzonen, Schaltjahre etc.). Man sucht sich heraus, was man braucht und verwendet die angebotenen Klassen mit ihren Methoden. Mit der JShell kann man rasch den Gebrauch solcher Klassen ausprobieren.\n\njshell&gt; import java.time.LocalDate;\n\njshell&gt; LocalDate.of(2024,12,16)\n$3 ==&gt; 2024-12-16\n\njshell&gt; import java.time.Period;\n\njshell&gt; Period.between($3, LocalDate.of(2026,12,16))\n$5 ==&gt; P2Y\n\njshell&gt; $5.getYears()\n$6 ==&gt; 2\nWas man hier lernt:\n\nDie toString-Methode ist in beiden Klassen angepasst, damit man wei√ü, wof√ºr das Objekt steht. P2Y ist also eine Kurzdarstellung einer Periode von 2 Jahren (years).\nDie Instanzen dieser beiden Klassen bieten einige Methoden an. Hier verwenden wir die getYears-Methode.\nLocalDate.of und Period.between sind Klassenmethoden (static methods). Woran man das erkennt? LocalDate und Period sind Klassen. W√§ren of und between Instanzmethoden, dann h√§tte man zuvor mit new ein Objekt anlegen m√ºssen. Interessanterweise wird dennoch eine Instanz der entsprechenden Klasse zur√ºckgeliefert. Wie das geht, schauen wir uns sp√§ter bei der Klasse Person an.\n\n\n\n1.3.2 Die √ºberarbeitete Klasse Person\nStatt einer Altersangabe geben wir im Konstruktor ein Geburtsdatum birth und optional (wahlweise) einen Namen name an.\nDamit niemand Zugriff auf die Variable birth hat, denn das Geburtsdatum soll nicht ver√§ndert werden k√∂nnen (auch nicht in der JShell), ist die Variable auf private gesetzt. Der Name kann auch sp√§ter nach der Geburt oder irgendwann im Leben einer Person angepasst werden. Der Zugriff auf die Variable ist nicht reglementiert.\nDas Alter wird √ºber die Methode getAge abh√§ngig von einem gegebenen Datum (oder dem aktuellen Tagesdatum) berechnet. F√ºr Zeitr√§ume die vor der Geburt liegen, wir eine ‚Äúnegative‚Äù Dauer angegeben.\nimport java.time.LocalDate;\nimport java.time.Period;\n\nclass Person {\n    private LocalDate birth;\n    String name;\n    Person(LocalDate birth, String name) {\n        this.birth = birth;\n        this.name = name;\n    }\n    Person(LocalDate birth) {\n        this(birth, \"\");\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }\n}\n\nWas man hier lernt:\n\nKonstruktoren sind eine besondere Form der Methode (Initialisierungsmethoden), die eine Instanz der Klasse zur√ºckgeben, es aber erlauben, z.B. √ºbergebene Initialisierungswerte vor der Zuweisung zu √ºberpr√ºfen (etwa mittels assert).\nMit this() kann man einen anderen Konstruktor (mit einer anderen Signatur) aufrufen. Auf diese Weise wird hier der Default-Wert (Standardwert) f√ºr name auf eine leere Zeichenkette gesetzt. (Alternativ h√§tte man String name = \"\"; deklarieren k√∂nnen.)\nDie Methode getAge ist f√ºr zwei verschiedene Signaturen deklariert. Auch hier sieht man, wie man Default-Werte setzen kann: Bei einem Aufruf ohne Argument wird das aktuelle Tagesdatum genutzt.\nDie toString-Methode passt die Repr√§sentation eines Objekts an die obige Notation an. Mit super bedient man sich der Standardrepr√§sentation der Oberklasse (stets Object bei Klassen, die keine Oberklasse mit extends angeben) und erg√§nzt mit + (String-Konkatenation, also String-Verkettung) die weiteren Angaben.\nDa die Klasse Person die Klasse Object erweitert, √ºberschreiben wir mit einer eigenen toString-Methode die der Oberklasse. Unsere lokale toString-Methode darf die Zugriffsrechte nicht reduzieren und muss deshalb ein public voranstellen.\nDas @Override ist eine sogenannte Annotation, die den Java-Compiler dazu veranlasst zu √ºberpr√ºfen, ob es in der Oberklasse eine Methode dieses Namens gibt. Wenn nicht, wird der √úbersetzungsvorgang mit einer Fehlermeldung abgebrochen. (Hinweis: Annotationen wie @Override werden in aller Regel nicht in die Methodenzeile geschrieben, sondern in einer separaten Codezeile vor dem Methodenkopf.)\nEs ist nicht notwendig, externe Klassen, die man mit import zur Nutzung bereitstellt, im Detail zu kennen und zu verstehen.\n\n\nEine getAge-Methode bedeutet nicht, dass es in der Klasse eine Variable namens age gibt ‚Äì wie das Beispiel zeigt. Es handelt sich hier nicht um eine sogenannte ‚ÄúGetter-Methode‚Äù.\n\nInteraktion:\njshell&gt; Person p1 = new Person(LocalDate.of(2000,6,1), \"Jo\")\np1 ==&gt; Person@4a87761d{ birth -&gt; 2000-06-01, name -&gt; \"Jo\" }\n\njshell&gt; p1\np1 ==&gt; Person@4a87761d{ birth -&gt; 2000-06-01, name -&gt; \"Jo\" }\n\njshell&gt; p1.name\n$39 ==&gt; \"Jo\"\n\njshell&gt; p1.birth\n|  Fehler:\n|  birth hat private-Zugriff in Person\n|  p1.birth\n|  ^------^\n\njshell&gt; p1.getAge()\n$40 ==&gt; P24Y6M15D\n\njshell&gt; p1.getAge().getYears()\n$41 ==&gt; 24\n\njshell&gt; p1.getAge(LocalDate.of(2010,7,1)).getYears()\n$42 ==&gt; 10\n\njshell&gt; p1.getAge(LocalDate.of(2010,5,1)).getYears()\n$43 ==&gt; 9\n\njshell&gt; p1.getAge(LocalDate.of(1995,5,1)).getYears()\n$44 ==&gt; -5\n\njshell&gt; p1.getAge(LocalDate.of(1995,7,1)).getYears()\n$45 ==&gt; -4\nAusprobieren:\nWas passiert, wenn man den Rumpf der toString-Methode folgenderma√üen verk√ºrzt?\n    @Override public String toString() {\n        return super.toString(); \n    }\nWas passiert, wenn man sich bei toString verschreibt (ToString)? Vergleichen Sie es mit @Override und ohne die Annotation.\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-person-mit-statischer-of-methode",
    "href": "Klassen.html#beispiel-person-mit-statischer-of-methode",
    "title": "1¬† Einfache Klassen",
    "section": "1.4 Beispiel: Person mit statischer of-Methode",
    "text": "1.4 Beispiel: Person mit statischer of-Methode\nimport java.time.LocalDate;\nimport java.time.Period;\n\nclass Person {\n    private LocalDate birth;\n    private String name = \"\";\n\n    static Person of(LocalDate birth) {\n        return new Person(birth); \n    }\n\n    private Person(LocalDate birth) {\n        LocalDate now = LocalDate.now();\n        assert birth.isBefore(now) ||\n               birth.isEqual(now) : \"Birthdate must not be in the future\"; \n        this.birth = birth;\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n    Person setName(String name) {\n        assert Objects.nonNull(name) : \"Name must not be null\";\n        name = name.trim(); // entfernt vor- und nachstehende Leerzeichen\n        assert !name.isEmpty() : \"Name must not be empty\";\n        this.name = name;\n        return this;\n    }\n    String getName() { \n        return name;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ \" +\n            \"birth -&gt; \" + birth + \", \" +\n            \"name -&gt; \\\"\" + name + \"\\\" }\"; \n    }\n}\nWas man hier lernt:\n\nNun sind die Variablen name und birth au√üerhalb der Klasse nicht einsehbar. F√ºr name sind zwei Methoden notwendig geworden: setName und getName. Allerdings, und das ist der Vorteil, wenn man Variablenwerte √ºber den Umweg von Methoden ver√§ndert, geschieht nun eine √úberpr√ºfung, ob der Name gewissen Anforderungen gen√ºgt.\nDer Konstruktor ist aufgrund von private nicht mehr von au√üerhalb der Klasse aufrufbar. Man muss jetzt Instanzen √ºber die Klassenmethode of erzeugen.\nDie Methode setName ist nicht void (was man auch h√§tte machen k√∂nnen), sondern sie gibt die eigene Person-Instanz mittels return this; zur√ºck. Das erlaubt es, Aufrufe zu verketten, siehe unten bei der Initialisierung von p2.\nSo kurz der Code auch ist, er implementiert eine eigene Logik des Umgangs mit der Idee einer ‚ÄúPerson‚Äù und kapselt sich sauber von der ‚ÄúUmwelt‚Äù ab. Eine Person kann ohne Namen erzeugt werden, allerdings darf das Geburtsdatum nicht in der Zukunft liegen. Ein sp√§ter nachgelieferter oder auch sp√§ter ge√§nderter Name kann niemals ‚Äúleer‚Äù sein, er muss aus mindestens einem Buchstaben bestehen. (Selbstredend kann man auch andere Datenlogiken als sinnvoll erachten. Das h√§ngt vom Einsatzzweck und dem Kontext ab.)\n\nInteraktion:\njshell&gt; Person p1 = Person.of(LocalDate.of(2000,12,6))\np1 ==&gt; Person@3224f60b{ birth -&gt; 2000-12-06, name -&gt; \"\" }\n\njshell&gt; p1.setName(\"Niki\")\n$10 ==&gt; Person@3224f60b{ birth -&gt; 2000-12-06, name -&gt; \"Niki\" }\n\njshell&gt; p1.getName()\n$11 ==&gt; \"Niki\"\n\njshell&gt; p1.getAge(LocalDate.of(2024,12,12))\n$12 ==&gt; P24Y6D\n\njshell&gt; Person p2 = Person.of(LocalDate.of(2000,12,6)).setName(\"Ty\")\np2 ==&gt; Person@614ddd49{ birth -&gt; 2000-12-06, name -&gt; \"Ty\" }\nFragen:\n\n\nH√§tte man f√ºr die Zusicherung in setName auch assert name != null verwenden k√∂nnen?\n\nJa, selbstverst√§ndlich. Gew√∂hnen Sie sich dennoch das sprechende Objects.nonNull(...) an. Die Klasse Objects bietet noch ein paar andere hilfreiche Methoden an.\n\n\n\nWarum beginnt der Konstruktor mit LocalDate now = LocalDate.now();? Man h√§tte die Zeile auch weglassen k√∂nnen und birth.isBefore(LocalDate.now()) und birth.isEqual(LocalDate.now()) schreiben k√∂nnen. Oder?\n\nEs ist ein √§u√üerst seltener Sonderfall: Zwischen den beiden LocalDate.now() k√∂nnte die Tagesgrenze liegen. Das w√ºrde zwar in diesem Fall keinen Schaden anrichten, aber es ist besser, mit der Variable now einen definierten Tageszeitpunkt zu w√§hlen, gegen√ºber dem die beiden Vergleiche vorgenommen werden.\n\nAusprobieren:\nVer√§ndern Sie die Methode setName auf den R√ºckgabetyp void. Was m√ºssen Sie am Code √§ndern? Was √§ndert sich an der Interaktion?",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#counter-beispiel-klassen--und-instanzmethoden-bzw.--variablen",
    "href": "Klassen.html#counter-beispiel-klassen--und-instanzmethoden-bzw.--variablen",
    "title": "1¬† Einfache Klassen",
    "section": "1.5 Counter-Beispiel: Klassen- und Instanzmethoden bzw. -Variablen",
    "text": "1.5 Counter-Beispiel: Klassen- und Instanzmethoden bzw. -Variablen\nIn einer Klassendeklaration sind Klassenvariablen von Instanzvariablen durch das Schl√ºsselwort static unterscheidbar; gleiches gilt f√ºr Klassenmethoden.\nclass Counter {\n    static int number  = 0;\n    int tick = 0;\n    static String showClass() {\n        return \"Counter{ counter = \" + number + \" }\";\n    }\n    Counter() {\n        number++;\n    }\n    Counter click() {\n        tick++;\n        return this;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ tick = \" + tick + \" }\";\n    }\n}\nWas man hier lernt:\n\nKlassenvariablen und -methoden (static) gelten nur im Kontext der Klasse. Darum m√ºssen Sie von au√üerhalb (z.B. von der JShell) √ºber den Klassennamen adressiert werden. In dem Fall also Counter.number bzw. Counter.show(). Innerhalb der Klasse ist die Erw√§hnung der Klasse nicht n√∂tig.\nInstanzvariablen und -methoden gelten nur f√ºr die Instanz. Um sich die Instanz zu erhalten, muss sie in einer Variablen gespeichert sein, z.B. in Counter c1. Dann erfolgt der Zugriff auf die Variable bzw. die Methode √ºber c1.tick bzw. c1.click().\nInnerhalb der Klasse kann eine Instanz auch √ºber das Schl√ºsselwort this auf die eigene Variable bzw. die Methode zugreifen: this.tick bzw. this.click(). Allerdings verzichtet man in aller Regel auf this, der Compiler f√ºgt das automatisch hinzu.\n\nInteraktion:\njshell&gt; Counter.number\n$3 ==&gt; 0\n\njshell&gt; Counter c1 = new Counter()\nc1 ==&gt; Counter@2f686d1f{ tick = 0 }\n\njshell&gt; Counter.number\n$5 ==&gt; 1\n\njshell&gt; Counter c2 = new Counter()\nc2 ==&gt; Counter@6e06451e{ tick = 0 }\n\njshell&gt; Counter.number\n$7 ==&gt; 2\n\njshell&gt; c1.click().click().click()\n$8 ==&gt; Counter@2f686d1f{ tick = 3 }\n\njshell&gt; c2.click()\n$9 ==&gt; Counter@6e06451e{ tick = 1 }\n\njshell&gt; Counter.number\n$10 ==&gt; 2\n\njshell&gt; c1.tick\n$11 ==&gt; 3\n\njshell&gt; c2.tick\n$12 ==&gt; 1\n\nMit Klassenvariablen und Klassenmethoden sollte man nur arbeiten, wenn der Gebrauch gut begr√ºndet ist. In der Mehrzahl der F√§lle m√∂chte man den Kontext von Instanzen nutzen, damit man von den Vorteilen der Objektorientierung profitiert.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#ausblick-record-datenklasse",
    "href": "Klassen.html#ausblick-record-datenklasse",
    "title": "1¬† Einfache Klassen",
    "section": "1.6 Ausblick: record (Datenklasse)",
    "text": "1.6 Ausblick: record (Datenklasse)\nIn modernem Java w√ºrde man die Klasse Person eher als Datenklasse (record) umsetzen. Der Code f√§llt dann k√ºrzer aus.\n\nZu Datenklassen gibt es vieles mehr zu sagen. Dieser Abschnitt soll nur zeigen, wie eine Umsetzung als Datenklasse aussieht und einer ersten Ber√ºhrung mit Datenklassen dienen.\n\nimport java.time.LocalDate;\nimport java.time.Period;\n\nrecord Person(LocalDate birth, String name) {\n    public Person {\n        assert Objects.nonNull(name) : \"Name must not be null\";\n        name = name.trim(); // entfernt vor- und nachstehende Leerzeichen\n        assert !name.isEmpty() : \"Name must not be empty\";   \n    }\n    Person(LocalDate birth) {\n        this(birth, \"\");\n    }\n    Person setName(String name) {\n        return new Person(birth, name);\n    }\n    Period getAge(LocalDate date) {\n        return Period.between(birth, date);\n    }\n    Period getAge() {\n        return getAge(LocalDate.now());\n    }\n}\n\nDie im Konstruktor angegebenen Variablen sind (1) final, d.h. unver√§nderlich (immutable) und es werden (2) f√ºr die Variablen automatisch Abrufmethoden angelegt, hier birth() und name().\nAufgrund der Immutabilit√§t (nicht √úberschreibbarkeit) von Variablen in Datenklassen, kann man auch keine Variablenwerte mehr nach dem Konstruktoraufruf √§ndern! Wenn man also den Namen mit setName anpassen m√∂chte, muss man eine neue Instanz von Person zur√ºckgeben, die das Geburtsdatum beibeh√§lt, aber mit einem neuen Namen versehen ist. Datenklassen verlangen nach einem anderen Programmierstil!\nDie √úberpr√ºfung f√ºr den Wert von name muss in den Konstruktor wandern. Grund ist wieder die Immutabilit√§t.\nDatenklassen erzeugen automatisch eine toString-Methode, die die Variablenwerte aus dem Konstruktur enth√§lt und anzeigt. Das ist in den meisten F√§llen praktisch und hilfreich.\nWenn man m√∂chte, k√∂nnte man auch hier eine Klassenmethode namens of anlegen, was bei Datenklassen aber in der Regel weniger Sinn macht.\n\nInteraktion:\njshell&gt; new Person(LocalDate.of(2000,1,1), \"Sy\")\n$25 ==&gt; Person[birth=2000-01-01, name=Sy]\n\njshell&gt; Person p = new Person(LocalDate.of(2000,1,1), \"Sy\")\np ==&gt; Person[birth=2000-01-01, name=Sy]\n\njshell&gt; p.name()\n$27 ==&gt; \"Sy\"\n\njshell&gt; p.birth()\n$28 ==&gt; 2000-01-01\n\njshell&gt; p = p.setName(\"Zu\")\np ==&gt; Person[birth=2000-01-01, name=Zu]\n\njshell&gt; p.getAge()\n$30 ==&gt; P24Y11M15D\nFragen:\n\n\nWarum hei√üt es in der Interaktion p = p.setName(\"Zu\")?\n\nWenn p eine Variable ist, die ein und die selbe Person repr√§sentieren soll, dann muss die neue Instanz von Person dem p zugewiesen werden. Grunds√§tzlich sollte die neue Instanz einer Variablen zugewiesen werden, weil ein einfaches p.setName(\"Zu\") ein nicht gespeichertes Objekt zur Folge h√§tte, was somit nicht mehr zugreifbar ist. In der JShell erfolgt die Zuweisung zu einer Variablen automatisch, damit man leichter experimentieren kann.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#beispiel-stringcomposer-methoden√ºberladung-method-overloading",
    "href": "Klassen.html#beispiel-stringcomposer-methoden√ºberladung-method-overloading",
    "title": "1¬† Einfache Klassen",
    "section": "1.7 Beispiel StringComposer: Methoden√ºberladung (method overloading)",
    "text": "1.7 Beispiel StringComposer: Methoden√ºberladung (method overloading)\nDie Signatur einer Methode setzt sich zusammen aus dem Methodennamen und den Typen ihrer Parameter. Signaturen unterscheiden sich im Methodennamen und, bei gleichem Methodennamen, in der Anzahl und Reihenfolge der Typparameter. Ausdr√ºcklich nicht zur Signatur z√§hlen der R√ºckgabetyp einer Methode, Ausnahmen (die kann man im Methodenkopf angeben) und die Parameternamen.\nGibt es zu einem Methodennamen mehrere unterschiedliche Signaturen, spricht man von Methoden√ºberladung. Das meint: Man kann die Methode unter ihrem Namen mit unterschiedlichen Argumenttypen und/oder einer unterschiedlichen Anzahl von Argumenten aufrufen.\nDas nachstehende Beispiel zeigt die Methoden√ºberladung f√ºr die Methode append. Die Signaturen unterscheiden sich eindeutig (sonst w√ºrde der Compiler einen Fehler melden), so dass beim Methodenaufruf stets die passende Methode ausgew√§hlt wird.\nclass StringComposer {\n    String s;\n    StringComposer(String s) { this.s = s; }\n    String append(int n) { return s += n; }\n    String append(String text) { return s += text; }\n    String append(String text, int times) {\n        for (int i = 1; i &lt;= times; ++i) s += text;\n        return s;\n    }\n    String append(int n, int times) { return append(\"\" + n, times); }\n    String append(String... texts) {\n        for (String text : texts) s += text;\n        return s;\n    }\n    String append(String a, String b) {\n        return s += a + b;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ s -&gt; \\\"\" + s + \"\\\" }\";\n    }\n}\nWas man hier lernt\n\nDie Signaturen lauten append(int), append(String), append(String, int) usw. Sie m√ºssen alle unterschiedlich sein. Man sagt: Die Methode append ist √ºberladen. (Im Beispiel sind alle R√ºckgabetypen gleich. Das m√ºsste nicht so sein.)\nBeim Aufruf wird die spezifischste Methode gew√§hlt. Bei einer bzw. zwei Zeichenketten im Aufruf, werden die Methoden mit den Signaturen append(String) bzw. append(String, String) gew√§hlt. Bei keiner, drei oder mehr Zeichenketten greift append(String...).\nEine Zuweisung wie z.B. s += text ver√§ndert nicht nur eine Variable, sie gibt zudem den Zuweisungswert zur√ºck. Das erlaubt neben der Zuweisung eine R√ºckgabe des Werts mittels return.\n\nInteraktion\njshell&gt; StringComposer sc = new StringComposer(\"Hi\")\nsc ==&gt; StringComposer@6500df86{ s -&gt; \"Hi\" }\n\njshell&gt; sc.append(3)\n$3 ==&gt; \"Hi3\"\n\njshell&gt; sc.append(\"You\")\n$4 ==&gt; \"Hi3You\"\n\njshell&gt; sc.append(\"c\", 3)\n$5 ==&gt; \"Hi3Youccc\"\n\njshell&gt; sc.append(5, 3)\n$6 ==&gt; \"Hi3Youccc555\"\n\njshell&gt; sc.append(\"a\", \"b\")\n$7 ==&gt; \"Hi3Youccc555ab\"\n\njshell&gt; sc.append(\"a\", \"b\", \"c\", \"d\")\n$8 ==&gt; \"Hi3Youccc555ababcd\"\n\njshell&gt; sc.append()\n$9 ==&gt; \"Hi3Youccc555ababcd\"\n\njshell&gt; sc\nsc ==&gt; StringComposer@6500df86{ s -&gt; \"Hi3Youccc555ababcd\" }\nAusprobieren\nVer√§ndern Sie den R√ºckgabewert einer append-Methode in void. √Ñndert das etwas an der Methoden√ºberladung?\nSind Sie sicher, dass sc.append(\"a\", \"b\") nicht die Methoden mit der Signatur append(String...) aufruft? Ver√§ndern Sie den Code in den Methodenr√ºmpfen so, dass unterscheidbar ist, welche Methode aufgerufen wird. (Im Zweifel d√ºrfen Sie ausnahmsweise System.out.println verwenden.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#counter-initiale-codebl√∂cke-static-...-und-...",
    "href": "Klassen.html#counter-initiale-codebl√∂cke-static-...-und-...",
    "title": "1¬† Einfache Klassen",
    "section": "1.8 Counter: Initiale Codebl√∂cke static { ... } und { ... }",
    "text": "1.8 Counter: Initiale Codebl√∂cke static { ... } und { ... }\nDas obige Schema f√ºr eine Klassendeklaration hat zwei initiale Codebl√∂cke unterschlagen, die in einer Klassendeklaration vorkommen k√∂nnen.\nclass &lt;Name&gt; {\n    static { /* Klasseninitialisierung */ }\n    { /* Instanzinitialisierung */ }\n    &lt;Deklaration von Klassenvariablen mit `static`&gt;\n    &lt;Deklaration von Instanzvariablen&gt;\n    &lt;Deklaration von Klassenmethoden mit `static`&gt;\n    &lt;Deklaration von Instanzmethoden&gt;\n}\nMan kann in einer Klassendeklaration einen statischen Block static { ... } einf√ºgen, der zur Ladezeit der Klasse ausgef√ºhrt wird, und einen Block { ... }, der beim Instanziieren von Objekten zur Ausf√ºhrung kommt.\nNehmen wir die Klasse Counter und f√ºgen in den Initialisierungbl√∂cken println-Anweisungen ein zur Nachvollziehbarkeit des Zeitpunkts der Ausf√ºhrung des Blocks.\nclass Counter {\n    static int number  = 0;\n    int tick = 0;\n    static {\n        System.out.println(\"Executed at class loading time\");\n    }\n    { \n        System.out.println(\"Executed prior to constructor call\");\n    }\n    static String showClass() {\n        return \"Counter{ counter = \" + number + \" }\";\n    }\n    Counter() {\n        number++;\n    }\n    Counter click() {\n        tick++;\n        return this;\n    }\n    @Override public String toString() {\n        return super.toString() + \"{ tick = \" + tick + \" }\";\n    }\n}\nKopiert man den Code in die JShell und erzeugt eine erste Instanz, sieht man deutlich den Effekt der Bl√∂cke. Der statische Init-Block (Klasseninitialisierung) wird nur ein einziges Mal aufgerufen, der andere Init-Block (Instanzinitialisierung) wird bei jeder Instanziierung aufgerufen und zwar vor der Abarbeitung des Codes im Konstuktor.\nInteraktion\njshell&gt; new Counter()\nExecuted at class loading time\nExecuted prior to constructor call\n$2 ==&gt; Counter@2f686d1f{ tick = 0 }\n\njshell&gt; new Counter()\nExecuted prior to constructor call\n$3 ==&gt; Counter@6e06451e{ tick = 0 }\n\njshell&gt; new Counter()\nExecuted prior to constructor call\n$4 ==&gt; Counter@6e1567f1{ tick = 0 }\n\nMan sollte den Block f√ºr die Instanzinitialisierung nicht als Ersatz f√ºr einen Konstruktor nehmen und auf seinen Gebrauch verzichten. Gleiches gilt f√ºr den Block zur Klasseninitialisierung. Man sollte also wissen, dass es diese Bl√∂cke gibt, sie aber nur dann einsetzen, wenn es sehr gute Gr√ºnde daf√ºr gibt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#gratis-methoden-von-object",
    "href": "Klassen.html#gratis-methoden-von-object",
    "title": "1¬† Einfache Klassen",
    "section": "1.9 ‚ÄúGratis‚Äù-Methoden von Object",
    "text": "1.9 ‚ÄúGratis‚Äù-Methoden von Object\nKlassen, die ohne ein explizites extends im Kopf der Deklaration auskommen, haben ein implizites extends Object da stehen. Die Klassen dieses Kapitels kann man also gedanklich im Deklarationskopf lesen als:\nclass Person extends Object { /* body */ }\n\nclass Counter extends Object { /* body */ }\n\nclass StringComposer extends Object { /* body */ }\nJede ‚Äúeinfache‚Äù Klasse erweitert die Klasse Object. Das hat zur Folge, dass jede Klasse die folgenden Methoden von Object √ºbernimmt oder ausdr√ºcklich mit einer eigenen Implementierung √ºberschreibt:\n\nprotected Object clone()\n\nErzeugt eine Kopie des Objekts\n\npublic boolean equals(Object other)\n\nObjekte vergleicht man in aller Regel nicht mit dem Gleichheitsoperator == (es sei denn, man m√∂chte die Identit√§t, d.h. die Referenzgleichheit der Objekte √ºberpr√ºfen), sondern mit Hilfe der equals-Methode, die es erlaubt, die inhaltliche Gleichheit von Objekten anhand ihrer Datenwerte zu √ºberpr√ºfen. Allerdings muss man diese Methode √ºberschreiben und mit einer passenden Implementierung ersetzen. Mehr dazu in einem gesonderten Abschnitt.  Die Standard-Implementierung in Object sieht wie folgt aus:\n\n\n    public boolean equals(Object other) {\n        return this == other;\n    }\n\npublic final Class&lt;?&gt; getClass()\n\nLiefert die Laufzeit-Repr√§sentation der Klasse des Objekts.\n\npublic int hashCode()\n\nGibt den HashCode eines Objekts zur√ºck. Der HashCode f√ºr ein Objekt wird ben√∂tigt f√ºr Datenstrukturen wie z.B. die HashMap. Zwei Objekte die gleich sind, m√ºssen den gleichen HashCode haben.\n\npublic String toString()\n\nLiefert eine Repr√§sentation, d.h. eine textuelle Selbstdarstellung des Objekts zur√ºck. Die Standards-Implementierung von Object sieht (geringf√ºgig vereinfacht) wie folgt aus:\n\n\n    public String toString() {\n        return getClass().getName() + \"@\" + \n               Integer.toHexString(hashCode());\n    }\nDie noch verbleibenden Methoden notify(), notifyAll() und die √ºberladene Methode wait(...) sind relevant f√ºr die nebenl√§ufige Programmierung mit Threads. Das wollen wir an dieser Stelle vorerst √ºbergehen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#was-genau-ist-ein-objekt",
    "href": "Klassen.html#was-genau-ist-ein-objekt",
    "title": "1¬† Einfache Klassen",
    "section": "1.10 Was genau ist ein Objekt?",
    "text": "1.10 Was genau ist ein Objekt?\nTechnisch gesprochen belegt ein Objekt einen Speicherbereich in einem Speicher, der sich Heap (engl. f√ºr ‚ÄúHaufen‚Äù) nennt. Der Heap ist ein verwalteter Speicherbereich. Die Speicherverwaltung schafft Platz f√ºr neu dazukommende Objekte, reorganisiert gelegentlich den Speicher (z.B. wenn es zu viele L√ºcken gibt, so dass neue Objekte Platz finden) und k√ºmmert sich darum, dass Objekte, die direkt oder indirekt durch die aktiven Referenzen nicht mehr erreicht werden, aus dem Heap entfernt werden; dies nennt sich Garbage Collection (GC, Speicherbereinigung).\nWenn in Java der new-Operator zum Einsatz kommt, wird ein Objekt erzeugt. Nehmen wir den obigen Code zur Klasse Person zur Anschauung (die Variante mit der of-Methode):\njshell&gt; Person p = Person.of(LocalDate.of(2000,1,1)).setName(\"Jes\")\np ==&gt; Person@5ce81285{ birth -&gt; 2000-01-01, name -&gt; \"Jes\" }\nZum Anlegen des Objektes werden in der Klasse Person lediglich die Instanzvariablen (die ‚Äúnormalen‚Äù und nicht als static ausgewiesenen Variablendeklarationen) betrachtet. Entsprechend der dortigen Typangaben wird der ben√∂tigte Speicherplatz f√ºr die Variablen bereitgestellt. Auf dem Heap kommt das Objekt mit folgendem Speicheraufbau unter einer dynamisch vergebenen Speicheradresse zum Tragen:\n\nSpeicherorganisation eines Objekts, das eine Instanz von Person ist\n\n\nOffset\nBytes\nFeld\nBeschreibung\n\n\n\n\n0\n8\nMark Word\nMetadaten: HashCode, Synchronisation, GC\n\n\n8\n8\nClass Pointer\nVerweis auf die Klassenbeschreibung\n\n\n16\n4\nbirth\nReferenz auf LocalDate-Instanz\n\n\n20\n4\nname\nReferenz auf String-Instanz\n\n\n24\n8\nPadding\nAuff√ºll-Bytes f√ºr Gesamtgr√∂√üe von 32 Bytes\n\n\n\nOhne hier auf alle Details einzugehen: Neben der Speicheradresse (dem entspricht die Referenz) f√ºr diesen Speicherblock, weist die Tabelle die entscheidenden und wichtigen Infos aus: Den HashCode (sofern er nicht √ºber eine √ºberschriebene hashCode-Methode berechnet wird), den Verweis auf die Klasse, von der das Objekt instanziiert wird (erh√§ltlich √ºber getClass()), und die Speicherbedarfe f√ºr die Instanzvariablen, hier Referenzen auf die Objekte von den Klassen LocalDate und String.\nDie Variable p im obigen Beispiel enth√§lt also die Referenz auf ein Objekt, das eine Instanz der Klasse Person ist. Der Referenz entspricht die Speicheradresse, an der der Speicherblock f√ºr das Objekt beginnt. Die Speicheradresse ist nicht einsehbar, sie wird aber intern herangezogen, wenn zwei Objekte auf Gleichheit mit dem Operator == gepr√ºft werden.\nAls Mensch helfen die technischen Einblicke f√ºr das Verst√§ndnis, aber Bilder sind besser, um einen Gesamtblick zu bekommen. Man kann Referenzen sehr gut als Pfeile (= Verweise) auf Objekte verstehen, wobei der Name am Pfeil den Variablennamen kennzeichnet. Objekte sind in dem nachstehenden Bild als K√§sten mit abgerundeten Ecken dargestellt. In dem Objekt steht entweder der Name der Klasse, von der das Objekt instanziiert wurde, oder seine Repr√§sentation, wie sie durch die toString-Methode bestimmt ist.\n\n\n\nEine Instanz von Person",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "Klassen.html#footnotes",
    "href": "Klassen.html#footnotes",
    "title": "1¬† Einfache Klassen",
    "section": "",
    "text": "Ich unterschlage hier, dass in dem Schema zwei Arten von Initialisierungsbl√∂cken vorkommen: der Block static { ... }, der zur Ladezeit der Klasse ausgef√ºhrt wird, und der Block { ... }, der beim Instanziieren von Objekten ausgef√ºhrt wird.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einfache Klassen</span>"
    ]
  },
  {
    "objectID": "KodierungUndRepr√§sentation.html",
    "href": "KodierungUndRepr√§sentation.html",
    "title": "2¬† Kodierung und Repr√§sentation",
    "section": "",
    "text": "2.1 Wie kommt man zu Programmcode?\nDas Programmieren ist eine fortw√§hrende Auseinandersetzung mit der Frage: Wie bilde ich einen Sachverhalt, eine Idee, eine Vorstellung, eine Konzeption etc. in Programmcode ab, d.h. in Anweisungen und Daten?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kodierung und Repr√§sentation</span>"
    ]
  },
  {
    "objectID": "KodierungUndRepr√§sentation.html#wie-kommt-man-zu-programmcode",
    "href": "KodierungUndRepr√§sentation.html#wie-kommt-man-zu-programmcode",
    "title": "2¬† Kodierung und Repr√§sentation",
    "section": "",
    "text": "2.1.1 Worum es geht: Sachverhalt, Kodierung, Programmcode, Rekonstruktion\nDie technische Auseinandersetzung, die durch diese Frage angesto√üen wird, umfasst vier Aspekte:\n\nErschlie√üe Dir den Sachverhalt, die Idee, die Vorstellung, die Konzeption etc. in einer Form, die sie prinzipiell √ºbertragbar (abbildbar) in Programmcode macht.\nFinde eine √úbertragung (Kodierung) mit den M√∂glichkeiten der Programmiersprache, die rechnerisch vorteilhaft ist und zur Programmiersprache und/oder zu einer Programmbibliothek mit ihren Ausdrucksmitteln passt.\nSetze die Kodierung mit Programmcode um.\nRekonstruiere aus der Umsetzung mit den gew√§hlten Ausdrucksmitteln der Programmiersprache oder der Programmbibliothek eine Darbietung, die den Sachverhalt, die Idee, die Vorstellung oder Konzeption vollst√§ndig oder in ihren wesentlichen Elementen wieder erkennbar macht.\n\nDiese vier Aspekte sind miteinander verflochten und lassen sich nur begrenzt analytisch voneinander trennen. Entscheidend ist, dass dieser Prozess auf zwei Repr√§sentationen (dem Sachverhalt und dem Programmcode) und auf einer Abbildung namens Kodierung (technisch w√ºrde man das als Enkodierung bezeichnen) und einer R√ºckabbildung namens Rekonstruktion (einer Dekodierung) besteht, siehe Abbildung¬†2.1.\n\n\n\n\n\n\nAbbildung¬†2.1: Zusammenhang von Repr√§sentation, Kodierung und Rekonstruktion\n\n\n\nDie Rekonstruktion muss nicht explizit erfolgen, sie kann gedanklich vollzogen werden, wird aber in aller Regel durch Interfaces manifestiert (das ist Stoff eines sp√§teren Kapitels) und kann validiert (√ºberpr√ºft) werden.\n\n\n\n2.1.2 Nutze toString f√ºr die Darstellung der Kodierung oder der Rekonstruktion!\nSie werden feststellen, dass ich fast immer die toString-Methode anpasse, um etwas von der einen oder anderen Seite anzuzeigen.\n\nEntweder stelle ich Details aus der Programmkodierung dar. Das hilft, um eine korrekte Arbeitsweise nachvollziehen zu k√∂nnen und m√∂gliche Probleme mit der Kodierung zu entdecken.\nOder ich bringe eine Rekonstruktion, vollst√§ndig oder in relevanten Anteilen, des urspr√ºnglichen Sachverhalts zur Darstellung. Auch hier lassen sich Probleme entdecken, wenn die Darstellung nicht korrekt ist.\n\nObwohl man auf Zeichenketten beschr√§nkt ist, ist es m√∂glich, mit einer Beschreibungssprache wie z.B. DOT eine graphische Beschreibung zur√ºckzugeben.\nDie mit toString erzeugten Zeichenketten k√∂nnen auch bei der Formulierung von Testf√§llen hilfreich und n√ºtzlich sein. \n\n\n2.1.3 Definitionen: Repr√§sentation, Kodierung, Rekonstruktion\nMan muss beim Begriff der Kodierung acht geben, da insbesondere die Nachrichtentechnik den Begriff gepr√§gt hat, der u.a. durch die Kodierungstheorie fundiert ist. Bei der Programmierung geht es aber nicht um Kanal-, Quellen- oder Leitungskodierung, sondern neben der Zeichenkodierung und neben den Daten- und Dateiformaten im Wesentlichen um die Abbildung von Sachverhalten in Daten, Datenstrukturen und Datenverarbeitungsverfahren und daraus die Rekonstruktion der Sachverhalte. Darauf zielen die folgenden Definitionen ab:\n\nRepr√§sentation\n\nEine Repr√§sentation stellt eine Konfiguration (Zusammenstellung) von Entit√§ten samt ihrer Beziehungen textuell, graphisch, bildlich oder in einer anderen medialen Form dar. Diese Darstellungen bilden ideelle (abstrakte), realweltliche (konkrete), simulierte (virtuelle) oder rechnerische (computationale) Konstruktionen ab.\n\n\n\n\nKodierung\n\nEine Kodierung beschreibt allgemein die Abbildung einer Repr√§sentation in eine andere Repr√§sentation. In der Programmierung geht es wesentlich darum, Kodierungen f√ºr Datenrepr√§sentationen und Berechnungen zu finden bzw. zu verwenden, die computational vorteilhaft und/oder programmiersprachlich oder paradigmatisch geeignet und angemessen sind. \n\nRekonstruktion\n\nDie Rekonstruktion ist die Umkehrung der Kodierung. In der Programmierung ist die Rekonstruktion die Abbildung, die aus dem Programmcode die urspr√ºngliche Repr√§sentation wieder hervorbringt.\n\n\n\n\n\n2.1.4 Beispiel: Primitive Zahlentypen\nSie kennen diese verschiedenen Repr√§sentationen bereits f√ºr primitive Typen. Zahlen vom Typ byte, short, int und long werden intern im Zweierkomplement kodiert. Das Zweierkomplement bildet eine vorzeichenbehaftete Zahl in eine Bin√§rzahl fester Stellenanzahl (8 Bits bei byte, 16 bei short, 32 bei int und 64 bei long) ab. Die Kodierung ist so beschaffen, dass man im Zweierkomplement mit einer gew√∂hnlichen Bin√§raddition negative und positive Zahlen addieren kann und es keiner expliziten Operation der Subtraktion bedarf. Dekodiert bzw. rekonstruiert werden die Zahlen des Zweierkomplements jedoch im Zehnerformat mit einem Vorzeichen bei negativen Zahlen.\nBei Gleitkommazahlen wie float und double ist die Kodierung und der Bezug zwischen der bin√§ren und dezimalen Zahlenrepr√§sentation komplizierter. Der technische Standard IEEE 754 definiert die Darstellung von Bin√§r- und Dezimalzahlen f√ºr Gleitkommazahlen und f√ºr die Durchf√ºhrungen von Berechnungen.\nDatenwerte vom Typ char folgen der Zeichenkodierung UTF-8. UTF-8 legt fest, welches Zeichen bzw. Symbol wie durch welche bin√§re Zahlenkodierung abgebildet wird.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kodierung und Repr√§sentation</span>"
    ]
  },
  {
    "objectID": "KodierungUndRepr√§sentation.html#veranschaulichung-kodierung-eines-schachfelds",
    "href": "KodierungUndRepr√§sentation.html#veranschaulichung-kodierung-eines-schachfelds",
    "title": "2¬† Kodierung und Repr√§sentation",
    "section": "2.2 Veranschaulichung: Kodierung eines Schachfelds",
    "text": "2.2 Veranschaulichung: Kodierung eines Schachfelds\nBei der Programmierung von Brettspielen tritt deutlich zu Tage, hier am Beispiel des Schachspiels, welche unterschiedlichen Bedarfe und Zwecke verschiedene Repr√§sentationen erf√ºllen.\nIn Abbildung¬†2.2 (a) ist, streng genommen, kein Schachbrett, sondern ein schematisches Abbild eines Schachbretts zu sehen. Es befindet sich einzig der wei√üe K√∂nig auf dem Spielbrett; der K√∂nig wird durch ein Symbol repr√§sentiert. Die Spalten werden im Schach durch Buchstaben, die Reihen durch Zahlen kodiert. Damit kann das Spielfeld einer Spielfigur eindeutig angegeben werden.\n\n\n\n\n\n\n\n\n\n\n\n(a) Schachbrett-Darstellung mit dem wei√üen K√∂nig auf dem Feld mit der Koordinate f7\n\n\n\n\n\n\n\n\n\n\n\n(b) Schachfeld-Kodierung √ºbernimmt die Zweidimensionalit√§t der Darstellung. Der K√∂nig befindet sich auf dem Feld mit dem Index [5][6].\n\n\n\n\n\n\n\nAbbildung¬†2.2: Ein Schachbrett und seine zweidimensionale Kodierung. Die Indizes laufen f√ºr jede Dimension von 0 bis 7.\n\n\n\n\n2.2.1 Zweidimensionale Kodierung\nEs ist naheliegend, die Zweidimensionalit√§t der Darstellung als Kodierungsidee f√ºr die Programmierung aufzugreifen und das Spielfeld durch ein zweidimensionales Array etwa namens board abzubilden, siehe Abbildung¬†2.2 (b).\nWollte man den Spielzug des K√∂nigs von f7 nach g8 berechnen, so m√ºsste man zun√§chst √ºberpr√ºfen, ob der K√∂nig damit nicht √ºber den Rand hinausl√§uft. Situationen, in denen der K√∂nig am Spielfeldrand steht, m√ºssen als solche erkannt werden. Zudem muss sichergestellt sein, dass das Zielfeld nicht durch eine Figur der eigenen Farbe belegt ist. Der Programmcode dazu s√§he etwa folgenderma√üen aus:\nfinal int MOVE_UP_RIGHT_X = +1;\nfinal int MOVE_UP_RIGHT_Y = +1;\ntoPosX = fromPosX + MOVE_UP_RIGHT_X\ntoPosY = fromPosY + MOVE_UP_RIGHT_Y\nif ((toPosX &gt;= 0 && toPosY &lt;= 7) &&\n    (toPosY &gt;= 0 && toPosY &lt;= 7) {\n    if (isNotWhite(board[toPosX][toPosY]) {\n        // found valid move\n    }\n}\nEs bedarf zweier Additionen und insgesamt f√ºnf Vergleiche (isNotWhite ist der f√ºnfte Vergleich), um feststellen zu k√∂nnen, dass der K√∂nig von seiner Position aus nach rechts oben ziehen kann.\n\n\n2.2.2 Eindimensionale Kodierung\nWenn man von der eindimensionalen Darstellung, Abbildung¬†2.3 (a), zu einer eindimensionalen Kodierung √ºbergeht, siehe Abbildung¬†2.3 (b), und zus√§tzlich einen Rand um das Spielfeld herum einf√ºhrt, um ung√ºltige Z√ºge durch ein Betreten des Spielfeldrands zu erkennen, vereinfacht sich die Berechnung.\n\n\n\n\n\n\n\n\n\n\n\n(a) Schachbrett-Darstellung mit dem wei√üen K√∂nig auf dem Feld mit der Koordinate f7\n\n\n\n\n\n\n\n\n\n\n\n(b) Eindimensionale Kodierung des Spielfelds. Die Indizierung der 120 Felder beginnt links oben mit 0 und endet rechts unten mit 119. Der K√∂nig steht auf dem Feld mit dem Index 36.\n\n\n\n\n\n\n\nAbbildung¬†2.3: Ein Schachbrett und seine eindimensionale Kodierung. Der rote Rand markiert Felder, die ung√ºltig sind. Das vereinfacht die Berechnung von Spielz√ºgen.\n\n\n\nDie Position des K√∂nigs wird nun durch eine einzige Zahl kodiert, der Spielzug durch eine relative Positionsangabe, hier -9.\nfinal int MOVE_UP_RIGHT = -9\ntoPos = fromPos + MOVE_UP_RIGHT\nif (board[toPos] != BORDER && isNotWhite(board[toPos]) {\n    // found valid move\n}\nBei eindimensionaler Kodierung ist der Zugriff auf ein Feld schneller und es gen√ºgen eine Addition und zwei Vergleiche. Der Programmcode ist einfacher aufgebaut und besser verst√§ndlich. All dies ist einer Kodierung zu verdanken, die sich nicht von der zweidimensionalen Repr√§sentation des Spielfelds leiten l√§sst, sondern zu einer rechnerisch geschickteren Repr√§sentation mit einem eindimensionalen Array wechselt.\n\n\n2.2.3 Zur Kodierung des Spielfeldrands\nDer verbreiterte Spielfeldrand begr√ºndet sich beim Schachspiel durch die Spielfigur des Springers, siehe Abbildung¬†2.4 (a). Ein Springer ist die einzige Figur, die durch einen Spielzug eines der acht Spielfelder in seinem Umfeld mit einem ‚ÄúRadius‚Äù von 2 erreicht. Bei einer eindimensionalen Kodierung kann man die acht Zugm√∂glichkeiten durch relative Positionsangaben angeben.\n\n\n\n\n\n\n\n\n\n\n\n(a) Ein Springer kann mit einem Spielzug eines von acht Spielfeldern erreichen, die auf einem Quadrat vom ‚ÄúRadius‚Äù 2 liegen. Ist das Ausgangsfeld wei√ü, sind die schwarzen Felder die Ziele; ist es schwarz, sind die Zielfelder wei√ü. Im Bild sind die relativen Sprungziele eingetragen, die Farbe der Felder ist damit unwichtig.\n\n\n\n\n\n\n\n\n\n\n\n(b) Der Springer befindet sind auf dem Feld mit dem Index 28. Mit Hilfe der relativen Springziele lassen sich die m√∂glichen Zielfelder berechnen. Nur zwei davon liegen im g√ºltigen Spielfeldbereich.\n\n\n\n\n\n\n\nAbbildung¬†2.4: Zur Erkl√§rung der Gestaltung des angef√ºgten Spielfeldrands.\n\n\n\nSteht der Springer in einer Ecke, siehe Abbildung¬†2.4 (b), muss der Rand so gestaltet sein, dass alle ung√ºltigen Z√ºge auf einem Feld im Rand landen. Die Verbreiterung ist so ausgelegt, dass der ‚ÄúRadius‚Äù von 2 ber√ºcksichtigt wird.\nDiese eindimensionale Kodierung mit einem Rand, der in einer visuellen Repr√§sentation des Spielfelds nat√ºrlich unsichtbar ist, ist das Ergebnis einer Abw√§gung: Mit ein wenig mehr an Speicherbedarf f√ºr den Rand gewinnt man eine schnellere Berechnung von Spielz√ºgen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kodierung und Repr√§sentation</span>"
    ]
  },
  {
    "objectID": "KodierungUndRepr√§sentation.html#fallbeispiel-tic-tac-toe",
    "href": "KodierungUndRepr√§sentation.html#fallbeispiel-tic-tac-toe",
    "title": "2¬† Kodierung und Repr√§sentation",
    "section": "2.3 Fallbeispiel: Tic-Tac-Toe",
    "text": "2.3 Fallbeispiel: Tic-Tac-Toe\nSie kennen sicher das Spiel Tic-Tac-Toe. Das Spiel besteht aus einem 3√ó3 Spielfeld und wird von zwei Parteien gespielt. Die eine Partei hat die mit X, die andere die mit O bezeichneten Spielsteine. Die beiden Spielparteien setzen abwechselnd ihre Spielsteine auf ein freies Feld, X beginnt. Das Spiel endet mit dem Sieg f√ºr die Spielpartei, die zuerst drei ihrer Spielsteine ‚Äúin Reihe‚Äù (waagerecht, senkrecht, diagonal) bringt. Kann keine Spielpartei gewinnen und ist das Spielbrett vollst√§ndig besetzt, so endet die Partie unentschieden.\nDie folgenden Unterkapitel demonstrieren anhand einer Umsetzung des Spiels Tic-Tac-Toe, die vielf√§ltigen Aspekte von Kodierungen.\n\n\n2.3.1 Einstieg: Wie w√ºrden Sie das Spiel kodieren?\nWir betrachten die folgende Situation im Spiel:\n\n\n\n\n\n\nAbbildung¬†2.5: Eine Spielsituation in Tic-Tac-Toe. Die Spielpartei mit X hat begonnen.\n\n\n\nWenn man danach fragt, mit welcher Datenstruktur das Spielfeld abgebildet (kodiert) werden k√∂nnte, bekommt man von Programmier-Neulingen oft eine √úberlegung wie diese zu h√∂ren:\n\nDas Spielfeld ist zweidimensional. Also kodiere ich das Spielfeld durch ein zweidimensionales Array.\nDie Spielsteine X und O (und ein Leerzeichen f√ºr ein leeres Feld) k√∂nnen durch ein char erfasst werden.\nFolglich w√§hle ich f√ºr das Spielfeld ein zweidimensionales char-Array: char[][] board = new char[3][3];\n\nVielleicht erahnen Sie es: Mit dieser Entscheidung wird die Darstellung des Spiels leitgebend f√ºr die interne Repr√§sentation des Spiels. Das wirft einige Probleme auf:\n\nDie interne Kodierung macht sich abh√§ngig davon, wie die Spielsteine symbolisch als Zeichen dargestellt werden. Was, wenn jemand lieber mit anderen Darstellungen f√ºr die Spielsteine spielt? Katastrophal w√§re, wenn man deshalb den Programmiercode anpassen m√ºsste.\nMit Einzelzeichen vom Typ char kann man zwar rechnen (char geh√∂rt in Java zu den Zahlentypen), doch daraus kann man keinerlei Nutzen ziehen. Denn: Wie will man mit diesen im Grunde willk√ºrlich gew√§hlten Symbolen X und O sinnvoll Berechnungen durchf√ºhren?\nDie Zweidimensionalit√§t erfordert, die Felder auf dem Spiel √ºber zwei Indizes zu adressieren. Wenn ein Programm Spielz√ºge durchrechnet, wie z.B. beim Schach- oder Damespiel, dann macht sich die Ineffizienz einer zweidimensionalen Adressierung deutlich bemerkbar.\n\n\n\n\n\n\n\nNimm das Kodieren ernst\n\n\n\nEs ist selten eine gute Idee, die √§u√üere Darstellung eines Sachverhalts eins zu eins auf die interne Datenrepr√§sentation zu √ºbertragen. Es ist die Aufgabe einer Programmiererin bzw. eines Programmierers eine Kodierung zu finden oder anzuwenden, die computational vorteilhaft und/oder programmiersprachlich oder paradigmatisch geeignet und angemessen ist (siehe die obige Definition!).\n\n\n\n\n2.3.2 Eine Kodierung f√ºr Tic-Tac-Toe\nMit den Instanzvariablen der Klasse TicTacToe fallen drei Entscheidungen f√ºr die interne Datenrepr√§sentation, siehe Abbildung¬†2.6.\n\nDas Spielfeld wird eindimensional durch ein Array int[] board abgebildet.\nDie Belegung eines Spielfelds ist wie folgt kodiert: Die Spielsteine der beginnenden Spielpartei (in der Darstellung das Symbol X) werden durch +1, die Spielsteine der nachziehenden Spielpartei (O) werden durch -1, leere Felder durch 0 abgebildet. Der Vorteil dieser Kodierung liegt darin, dass sich sehr effizient feststellen l√§sst, ob drei Spielsteine einer Partei eine Reihe ergeben: Man addiere die Feldwerte f√ºr eine Reihe auf. Ergibt sich eine +3 oder eine -3, sind drei Spielsteine einer Sorte in Reihe.\nStrikt von der internen Kodierung getrennt wird die Wahl der verwendeten Symbole f√ºr die Spielsteine durch das Array symbols vorgehalten.\n\n\n\n\n\n\n\nAbbildung¬†2.6: Die Kodierung des Spiels Tic-Tac-Toe: Ein eindimensionales Spielfeld, das die Spielparteien mit +1 und -1 und leere Felder mit 0 unterscheidet\n\n\n\nZus√§tzlich zu diesen Entscheidungen gibt es die folgenden Variablen:\n\nint turn merkt sich, wer am Zug ist, +1 oder -1. Entsprechend wechselt der Wert zwischen +1 und -1 hin und her.\nDer Spielverlauf wird in int[] history vorgehalten. Die Spielhistorie erlaubt die R√ºcknahme von Spielz√ºgen.\nDer counter z√§hlt die in history hinterlegten Z√ºge mit und kann somit zudem als F√ºllstandsanzeiger verstanden werden.\n\nclass TicTacToe {\n    private int[] board = {0,0,0,0,0,0,0,0,0};\n    private int turn = +1;\n    private char[] symbols = {'O','.','X'};\n    private int[] history = new int[board.length];\n    private int counter = 0;\nDie Variablen sind allesamt per private auf ‚Äúunsichtbar‚Äù geschaltet und von au√üerhalb nicht zugreifbar. Damit kapselt das Spiel alle Interna von au√üen ab. F√ºr Nutzende einer TicTacToe-Instanz ist es vollkommen intransparent und damit unwichtig, wie die Instanz intern das Spiel kodiert hat und arbeitet.\n\n\n2.3.3 Objekt-Repr√§sentation mit toString-Methode\nBei Referenztypen kann die textuelle Repr√§sentation eines Objekts mit Hilfe der toString-Methode individuell angepasst werden. Es ist eine Entscheidung der Programmierin bzw. des Programmierers, ob man dies nutzt, um Interna der internen Datenkodierung einsichtig zu machen oder um aus den Interna eine Abbildung f√ºr eine Au√üen-Darstellung zu konstruieren.\nIn diesem Beispiel wird die interne Kodierung √ºbersetzt in das anzuzeigendes Symbol. Das Spielfeld wird nur angedeutet, ich verzichte auf die horizontalen und vertikalen Linien.\n    public String toString() {\n        String repr = \"\";\n        for(int i = 0; i &lt; board.length; i++) {\n            if (i % 3 == 0) repr += \"\\n\";\n            repr += symbols[board[i] + 1];\n        }\n        return repr;\n    }\n}\nIn der JShell sieht das dann so aus:\njshell&gt; TicTacToe t3 = new TicTacToe(0,1,4,8,6)\nt3 ==&gt;\nXO.\n.X.\nX.O\n\n\n2.3.4 Konstruktoren, Spielzug ausf√ºhren (move) und r√ºckg√§ngig machen (undoMove)\nMit new TicTacToe() kann ein Spiel instanziiert werden. Bei Bedarf sind Spielz√ºge √ºbergebbar, die per move ausgef√ºhrt werden.\n    TicTacToe() { }\n    \n    TicTacToe(int ...moves) {\n        for(int move : moves) move(move);\n    }\n\n    public void move(int m) {\n        assert contains(generateMoves(), m): \"move must address a valid, empty field\";\n        assert !threeInARow(): \"no party should have won the game\";\n        board[m] = turn;\n        turn = -turn;\n        history[counter++] = m;\n    }\nWenn man von den verwendeten Methoden in den assert-Anweisungen absieht, ist die Umsetzung f√ºr einen Spielzug einfach nachzuvollziehen:\n\nDer Spielzug m, ein Wert von 0 bis 8, entspricht der Angabe des Indexes eines freien Feldes auf dem eindimensionalen Spielbrett.\nDas Feld wird mit dem Wert der am Zug befindlichen Spielpartei belegt. Anschlie√üend wechselt die Spielpartei.\nDer Spielzug wird im Ged√§chtnis f√ºr den Spielverlauf eingetragen.\n\njshell&gt; t3.move(3)\n\njshell&gt; t3\nt3 ==&gt;\nXO.\nOX.\nX.O\nDie Methode, um einen Spielzug r√ºckg√§ngig zu machen, liest sich fast wie das Inverse (Umgekehrte) der move-Methode. Faktisch entpsricht dies auch der Intention: ein ausgef√ºhrter Zug wird r√ºckabgewickelt.\n    public void undoMove() {\n        if (counter == 0) return;\n        board[history[--counter]] = 0;\n        turn = -turn;\n    }\njshell&gt; t3.undoMove()\n\njshell&gt; t3\nt3 ==&gt;\nXO.\n.X.\nX.O\n\n\n2.3.5 Der Spielzuggenerator generateMoves und die Hilfsmethode contains\nDer Zuggenerator bei Tic-Tac-Toe ist √§u√üerst simpel: Die freien Felder werden in einem Array eingetragen. Die Gr√∂√üe des Arrays ist vorab bestimmbar. (Ich habe mich hier f√ºr die R√ºckgabe eines int-Arrays entschieden, damit man keine Kenntnis von Datentypen wie ArrayList haben muss.)\n    public int[] generateMoves() {\n        int[] moves = new int[board.length - counter];\n        for(int i = 0, j = 0; i &lt; board.length; i++)\n            if (board[i] == 0) moves[j++] = i;\n        return moves;\n    }\nIn der aktuellen Spielsituation sind folgende Spielz√ºge m√∂glich:\njshell&gt; t3.generateMoves()\n$22 ==&gt; int[4] { 2, 3, 5, 7 }\nDie Hilfsmethode contains dient generell zur Feststellung, ob sich ein Zahlenwert vom Typ int in einem int-Array befindet. Da diese Methode nicht auf den Kontext des aktuellen Objekts und/oder seiner Instanzvariablen basiert und eine generelle Dienstleistung erbringt, ist diese Methode als Klassenmethode (static) deklariert. Da diese Dienstleistung aber eine interne Angelegenheit ist und f√ºr das Tic-Tac-Toe ansonsten keine Bedeutung hat, ist die Methode au√üerdem als private deklariert.\n    private static boolean contains(int[] numbers, int number) {\n        for (int n : numbers)\n            if (n == number) return true;\n        return false;\n    }\n\n\n2.3.6 Sind drei in Reihe? (threeInARow)\nEs gibt insgesamt acht M√∂glichkeiten f√ºr ‚ÄúDrei in Reihe‚Äù: es gibt drei Spalten, drei Zeilen und zwei Diagonalen. Statt diese acht M√∂glichkeiten durch zahlreiche if-Anweisungen zu kodieren, kann man auch eine datenorientierte L√∂sung realisieren. In dem zweidimensionalen Array rows werden die acht M√∂glichkeiten schlicht notiert. Die sich daraus ergebende Ablauflogik zur Feststellung, ob in der aktuellen Spielsituation drei Spielsteine einer Spielpartei in Reihe sind, ist √ºbersichtlich und einfach nachvollziehbar.\n    public boolean threeInARow() {\n        int[][] rows = {{0,1,2},{3,4,5},{6,7,8},\n                        {0,3,6},{1,4,7},{2,5,8},\n                        {0,4,8},{2,4,6}};\n        for(int[] row : rows) {\n            int sum = board[row[0]] + board[row[1]] + board[row[2]];\n            if (Math.abs(sum) == 3) return true;\n        }\n        return false;\n    }\njshell&gt; t3.threeInARow()\n$23 ==&gt; false\n\n\n\n\n\n\nAbbildung von Abl√§ufen in Datenstrukturen\n\n\n\nSie sehen in der Methode threeInARow, wie umfangreiche Anweisungsstrukturen in Datenstrukturen kodiert werden k√∂nnen. Die Repr√§sentationsebene der Anweisungsstruktur wird zu Teilen in eine Repr√§sentationsebene von Datenstrukturen abgebildet. Davon sollten Sie Gebrauch machen, wann immer das m√∂glich ist. Der mit der Datenstrukture einhergehende ‚ÄúRestcode‚Äù an Anweisungen ist meist deutlich weniger umfangreich, besser verst√§ndlich und weniger anf√§llig gegen ‚ÄúTippfehler‚Äù.\n\n\n\n\nWenn Sie die Umsetzung der Kodierung von Reihen in einem Array sehen, k√∂nnte man auf eine effizientere Variante kommen: Je nachdem wo der letzte Spielstein gesetzt wurde, sind nur zwei, drei oder vier Reihen zu √ºberpr√ºfen. Wie m√ºsste der Programmcode angepasst werden, um das umzusetzen?\n\nIch m√∂chte hier nur die Idee skizzieren:\n\nF√ºr das Feld mit dem Index 0 kommen nur die folgenden Reihen infrage: {{0,1,2}, {0,4,8}, {0,3,6}}. Entsprechendes gilt f√ºr die anderen Eckfelder.\nF√ºr das Feld mit dem Index 1 sind es die Reihen {{0,1,2}, {1,4,7}}. Entsprechendes gilt f√ºr die Indizes 3, 5 und 7.\nF√ºr das Feld in der Mitte mit dem Index 4 sind es die Reihen {{0,4,8}, {2,4,6}, {1,4,7}, {3,4,5}}\n\nMit jedem Index ist ein zweidimensionales Feld mit den Reihen zu verbinden. Entsprechend ist ein dreidimensionales Array zu konzipieren:\nint[][][] idx2rows = {\n    {{0,1,2}, {0,4,8}, {0,3,6}}, // Index 0\n    {{0,1,2}, {1,4,7}},          // Index 1\n    // usw.\n    {{0,4,8}, {2,4,6}, {1,4,7}, {3,4,5}} // Index 4\n    // usw.\n}\nAbh√§ngig vom letzten Zug k√∂nnen nun die zu begutachtenden Reihen abgerufen werden:\nint[][] rows = idx2rows[history[counter - 1]];\nDer Rest des Codes, d.h. die for-Schleife und das abschlie√üende return, bleibt unver√§ndert.\n\n\n\n2.3.7 R√ºckgabe des Spielverlaufs (history)\nDie Variable history, die den Spielverlauf erinnert, ist private gesetzt und von au√üen nicht einsehbar. Man k√∂nnte eine Methode wie int[] getHistory() (oder k√ºrzer int[] history()) anlegen, die per return history das int-Array zur√ºckgibt.\nDas w√§re ein schwerwiegender Fehler: Sie h√§tten damit die Referenz auf das Array ausgeliefert, was Au√üenstehenden beliebige Manipulationen an dem Array erlauben w√ºrde. Damit h√§tten Sie Ihren Programmcode unterwandert und k√∂nnten dessen Integrit√§t nicht mehr garantieren.\nUm die Referenz nicht nach au√üen zu geben, erzeugen wir eine Kopie des Arrays. Und zwar nicht des ganzen Arrays sondern nur von der ben√∂tigten Gr√∂√üe.\n    public int[] history() {\n        int[] moves = new int[counter];\n        for(int i = 0; i &lt; moves.length; i++)\n            moves[i] = history[i];\n        return moves;\n    }\njshell&gt; t3.history()\n$24 ==&gt; int[5] { 0, 1, 4, 8, 6 }\n\n\nDie Klasse java.util.Arrays (kurz Arrays in der JShell) bietet ein paar interessante Methoden im Umgang mit Arrays an, darunter die copy-Methode. Setzen Sie die obige Methode mit copy um.\n\nSie k√∂nnen den obigen Code damit verk√ºrzen zu:\n    public int[] history() {\n        return Arrays.copy(history, counter);\n    }\n\n\n\n\n\n\n\nMit immutablen Datenstrukturen gibt es kein Referenzproblem\n\n\n\nEine grunds√§tzlich andere L√∂sung zu der Herausforderung, die Datenintegrit√§t durch herausgegebene Referenzen nicht zu verletzen, ist die Verwendung von immutablen (unver√§nderlichen) Datenstrukturen. Wenn sich nichts an einem Objekt √§ndern l√§sst, ist es egal, wenn seine Referenz Dritten zug√§nglich ist. Daher spricht man bei Immutabilit√§t auch von referentieller Intransparenz. Auf die Immutabilit√§t kommen wir in anderen Kontexten wieder zur√ºck.\n\n\n\n\n2.3.8 Ver√§nderte Au√üendarstellung != interne Datenrepr√§sentation (toggle)\nAn der Methode toggle m√∂chte ich Ihnen demonstrieren, dass die Au√üendarstellung (Au√üenrepr√§sentation) von Tic-Tac-Toe eine Angelegenheit ist, die unabh√§ngig von der internen Datenrepr√§sentation des Spiels gepflegt und behandelt werden kann.\nWenn Sie die Spielparteien entschlie√üen, die Symbole der Spielsteine zu tauschen, so dass beispielsweise auch O ein Spiel beginnen kann, so hat das √ºberhaupt keinen Einfluss auf die interne Kodierung: dort wird stets der Anfang mit +1 gemacht.\n    TicTacToe toggle() {\n        char c = symbols[0];\n        symbols[0] = symbols[2];\n        symbols[2] = c;\n        return this;\n    }\njshell&gt; t3\nt3 ==&gt;\nXO.\n.X.\nX.O\n\njshell&gt; t3.toggle()\n$26 ==&gt;\nOX.\n.O.\nO.X\n\n\n2.3.9 Zur√ºck zum Anfang: Koordinaten f√ºr die Feldangabe\nKommen wir noch einmal zum Anfang zur√ºck: Verst√§ndlicherweise k√∂nnte der Bedarf vorliegen, einen Spielzug nicht √ºber einen eindimensionalen Feldindex anzugeben, der zudem mit Null beginnt, sondern √ºber eine zweidimensionale Koordinatenangabe, √§hnlich wie beim Schach, siehe Abbildung¬†2.7.\n\n\n\n\n\n\n\n\n\n\n\n(a) Zahlenkoordinate: Zuerst wird eine untere Zahl f√ºr die Spalte, dann eine der Seitenzahlen f√ºr die Zeile angegeben\n\n\n\n\n\n\n\n\n\n\n\n(b) Buchstabe/Zahl-Koordinate: Zuerst wird der Buchstabe, dann die Zahl angegeben. Auch umgekehrt w√§re die Kodierung eindeutig.\n\n\n\n\n\n\n\nAbbildung¬†2.7: Zwei m√∂gliche Koordinatensysteme f√ºr Tic-Tac-Toe\n\n\n\nDiese Koordinatensysteme stellen m√∂gliche Kodierungen dar, die mit der Au√üendarstellung des Spiels verbunden sind. Statt den Code der Klasse TicTacToe daf√ºr ‚Äúanzufassen‚Äù, stelle ich eine Klasse Pos mit der Klassenmethode of bereit, die die Umrechnung vornimmt.\nclass Pos {\n    static int of(int x, int y) {\n        assert x &gt;= 1 && x &lt;= 3;\n        assert y &gt;= 1 && y &lt;= 3;\n        return (3 - y) * 3 + (x - 1);\n    }\n    static int of(char x, int y) {\n        return of(x &lt; 'a' ? x - 'A' + 1 : x - 'a' + 1, y);\n    }\n}\n\n\n2.3.10 Testing\nAn den Tests, die ich mit der assert-Anweisung umsetze, m√∂chte ich Ihnen zeigen, dass die toString-Methode mit der Ausgabe der Spielsituation bei der Formulierung von Testf√§llen helfen kann. Hier ein paar Beispiele:\nassert new TicTacToe().toString().equals(\"\\n...\\n...\\n...\");\nassert new TicTacToe().toggle().toString().equals(\"\\n...\\n...\\n...\");\nassert new TicTacToe(0,2).toString().equals(\"\\nX.O\\n...\\n...\");\nassert new TicTacToe(7,3,0,2).toString().equals(\"\\nX.O\\nO..\\n.X.\");\nassert new TicTacToe(0,3,7,2).toggle().toString().equals(\"\\nO.X\\nX..\\n.O.\");\nassert new TicTacToe(0,6,1,7,2).threeInARow();\nassert new TicTacToe(0,6,1,7,3,8).threeInARow();\nDie Testf√§lle f√ºr die Klasse Pos arbeiten nicht mit Instanzen und m√ºssen die Klassenmethode of unmittelbar testen.\nassert Pos.of(1,3) == 0 && Pos.of(2,3) == 1 && Pos.of(3,3) == 2;\nassert Pos.of(1,2) == 3 && Pos.of(2,2) == 4 && Pos.of(3,2) == 5;\nassert Pos.of(1,1) == 6 && Pos.of(2,1) == 7 && Pos.of(3,1) == 8;\nassert Pos.of('a',2) == Pos.of('A',2) && Pos.of('a',2) == Pos.of(1,2);\nassert Pos.of('b',1) == Pos.of('B',1) && Pos.of('b',1) == Pos.of(2,1);\nassert Pos.of('c',2) == Pos.of('C',2) && Pos.of('c',2) == Pos.of(3,2);",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kodierung und Repr√§sentation</span>"
    ]
  },
  {
    "objectID": "KodierungUndRepr√§sentation.html#aufgaben",
    "href": "KodierungUndRepr√§sentation.html#aufgaben",
    "title": "2¬† Kodierung und Repr√§sentation",
    "section": "2.4 Aufgaben",
    "text": "2.4 Aufgaben\nErg√§nzen Sie folgende Methoden zu der Klasse TicTacToe:\n\n2.4.1 Verwende eine ArrayList f√ºr history\nVerwenden Sie f√ºr history eine ArrayList statt des int-Arrays und verzichten Sie damit auf √ºberfl√ºssig gewordene Variablen und Methoden.\n\n\nL√∂sen Sie die Aufgabe, schauen Sie erst dann hier nach, welche Variablen bzw. Methoden infrage kommen.\n\n\nDie ArrayList kann dynamisch wachsen und schrumpfen, der counter als F√ºllstandsanzeiger wird hinf√§llig, die size() gibt den F√ºllstand der ArrayList an.\nDie Hilfsmethode contains ist √ºberfl√ºssig, ArrayList liefert diese Methode mit.\nWenn die Methode history ihren R√ºckgabetyp int[] beibehalten soll, muss sie neu implementiert werden. Aber selbst in der Gestalt von ArrayList&lt;Integer&gt; history() hat sie ihre Berechtigung: Es darf nicht einfach history zur√ºckgegeben werden, weil damit die durch private gesch√ºtzte Referenz nach au√üen durchgestochen wird und von au√üen ver√§nderbar wird. Es muss also eine Kopie der ArrayList zur√ºckgegeben werden.\n\n\n\n\n2.4.2 Speichern und Laden von Spielst√§nden\nMit der Methode void save(String fileName) kann der Spielstand in einer Textdatei gespeichert werden. Die Dateiextension .txt wird automatisch zu fileName erg√§nzt. Die Methode void save() w√§hlt als Dateinamen \"t3\". Die Datei enth√§lt die Historie, wobei die Zahlen durch Kommata getrennt sind. Wurde noch kein Spielzug gemacht, wird eine leere Datei angelegt.\nMit der Methode TicTacToe load(String fileName) wird ein Spielstand aus der abgespeicherten Historie rekonstruiert. Mit TicTacToe load() wird t3.txt geladen.\n\n\nWarum ist es sinnvoller, die Historie f√ºr die Rekonstruktion des Spielstands zu speichern, statt eines Abbilds des tats√§chlichen Spielstands?\n\nEs ist gar nicht so einfach, einen gegebenen Spielstand daraufhin zu √ºberpr√ºfen, ob er eine g√ºltige Spielsituation wiedergibt. Denn die zu ladende Textdatei kann ja auch h√§ndisch angelegt worden oder schlicht fehlerhaft sein. Zum Beispiel darf die Summe aller Spielsteine auf dem Brett nur 0 oder +1 sein. Ansonsten hat eine Partei Spielsteine ohne Gegenzug auf dem Spielbrett positioniert. Wesentlich einfacher ist die Rekonstruktion eines Spielstands aus der Historie des Spielverlaufs. Die Spielz√ºge sind bei Verwendung der move-Methode (zusammen mit generateMoves und contains) sehr leicht auf G√ºltigkeit zu √ºberpr√ºfen. Wenn die Spielz√ºge g√ºltig sind, muss es die ergebende Spielsitation ebenso sein. Sie setzen also auf der bereits implementierten Spielmechanik (auch der G√ºltigkeitspr√ºfung) auf, statt neue √úberlegungen umsetzen zu m√ºssen, ob eine gegebene Spielstellung (a) grunds√§tzlich g√ºltig ist oder nicht und (b) ob sie √ºberhaupt durch einen realen Spielverlauf so entstanden sein k√∂nnte.\n\n\n\n\n\n\nTipp\n\n\n\nWenn Sie bei Spielen wie Tic-Tac-Toe oder Brettspielen wie Schach, M√ºhle oder Dame den Spielstand speichern wollen, sollten Sie das immer √ºber die Speicherung der bis dahin erfolgten Spielz√ºge tun. Die Rekonstruktion einer Spielsituation aus dem Spielverlauf ist leichter validierbar (√ºberpr√ºfbar) und sie kann korrumpierte Daten erkennen.\n\n\n\n\n\n2.4.3 Hocheffiziente Kodierungen: Bitboards\nWenn es darum geht, bei Spielen m√∂glichst effizient Spielz√ºge durchzurechnen (etwa bei der Suche nach einem besten Spielzug, wenn der Computer gegen den Menschen antritt), braucht es sehr ausgekl√ºgelte Kodierungen. In dem Text ‚ÄúBitboards and Connect Four‚Äù erkl√§re ich ausf√ºhrlich am Beispiel des Spiels ‚ÄúVier gewinnt‚Äù, was Bitboards sind und wie sie funktionieren. In dem Video ‚ÄúBitboards f√ºr Tic-Tac-Toe‚Äù zeige ich Ihnen die Umsetzung f√ºr das Spiel Tic-Tac-Toe.\n\n\n\n\n\n\nTipp\n\n\n\nEs gibt im Bereich der Algorithmen und Datenstrukturen f√ºr viele Sachverhalte und Problemstellungen sehr raffinierte, effiziente und gr√ºndlich analysierte Kodierungen ‚Äì das ist ein Teil dessen, was die Informatik so reizvoll und interessant macht. Machen Sie es sich zur Angewohnheit, zu dem Thema, das Sie besch√§ftigt, nach solchen Kodierungen zu recherchieren. Es ist unm√∂glich, selber auf all das zu kommen, was andere schon erfunden und ergr√ºndet haben. Vieles wird Ihnen auch durch Programmbibliotheken bereitgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kodierung und Repr√§sentation</span>"
    ]
  },
  {
    "objectID": "legal/impressum.html",
    "href": "legal/impressum.html",
    "title": "Impressum",
    "section": "",
    "text": "Prof.¬†Dr.¬†Dr.¬†Dominikus Herzberg Technische Hochschule Mittelhessen Fachbereich Mathematik, Naturwissenschaften und Informatik Wiesenstra√üe 14 35390 Gie√üen\nKontakt:\nTelefon: +49 (0)641 309 2300 Telefax: +49 (0)641 309 2908 E-Mail: dominikus.herzberg at mni dot thm dot de Website: https://www.thm.de/mni/dominikus-herzberg"
  },
  {
    "objectID": "legal/datenschutz.html",
    "href": "legal/datenschutz.html",
    "title": "Datenschutzerkl√§rung",
    "section": "",
    "text": "Verantwortliche Stelle\nIm folgenden m√∂chten wir Sie aufkl√§ren, wie Ihre Daten von uns verarbeitet werden.\nVerantwortlich im Sinne der DSGVO ist:\nProf.¬†Dr.¬†Dr.¬†Dominikus Herzberg Technische Hochschule Mittelhessen Fachbereich Mathematik, Naturwissenschaften und Informatik Wiesenstra√üe 14 35390 Gie√üen\nTelefon: +49 (0)641 309 2300 E-Mail: dominikus.herzberg at mni dot thm dot de\nSollten Sie per E-Mail mit uns Kontakt aufnehmen, werden die mitgeteilten Daten von uns gespeichert, um Ihr Anliegen zu bearbeiten.\nZu den verarbeiteten Daten z√§hlen:\nWir werden die Daten l√∂schen, sobald die Speicherung nicht mehr erforderlich ist oder die Verarbeitung einschr√§nken, falls gesetzliche Aufbewahrungspflichten bestehen."
  },
  {
    "objectID": "legal/datenschutz.html#verantwortliche-stelle",
    "href": "legal/datenschutz.html#verantwortliche-stelle",
    "title": "Datenschutzerkl√§rung",
    "section": "",
    "text": "Ihr Name\nIhre E-Mail-Adresse"
  },
  {
    "objectID": "legal/datenschutz.html#hosting",
    "href": "legal/datenschutz.html#hosting",
    "title": "Datenschutzerkl√§rung",
    "section": "Hosting",
    "text": "Hosting\nUnser Hoster erhebt in sogenannte Logfiles folgende Daten, die dein Browser √ºbermittelt:\nIP-Adresse, die Adresse der vorher besuchten Website (Referer Anfrage-Header), Datum und Uhrzeit der Anfrage, Zeitzonendifferenz zur Greenwich Mean Time, Inhalt der Anforderung, HTTP-Statuscode, √ºbertragene Datenmenge, Website, von der die Anforderung kommt und Informationen zu Browser und Betriebssystem.\nDas ist erforderlich, um unsere Website anzuzeigen und die Stabilit√§t und Sicherheit zu gew√§hrleisten. Dies entspricht unserem berechtigten Interesse im Sinne des Art. 6 Abs. 1 S. 1 lit. f DSGVO.\nEs erfolgt kein Tracking und wir haben auf diese Daten keinen direkten Zugriff, sondern erhalten lediglich eine anonymisierte, statistische Zusammenfassung. Diese beinhaltet die Adresse der vorher besuchten Seite, die H√§ufigkeit der jeweils aufgerufenen Seiten und die Anzahl eindeutiger Besucher. Diese Daten f√ºhren wir nicht mit anderen Daten zusammen.\nWir setzen f√ºr die Zurverf√ºgungstellung unserer Website folgenden Hoster ein:\nGitHub Inc. 88 Colin P Kelly Jr St San Francisco, CA 94107 United States\nDieser ist Empf√§nger deiner personenbezogenen Daten. Dies entspricht unserem berechtigten Interesse im Sinne des Art. 6 Abs. 1 S. 1 lit. f DSGVO, selbst keinen Server in unseren R√§umlichkeiten vorhalten zu m√ºssen. Serverstandort ist USA.\nWeitere Informationen zu Widerspruchs- und Beseitigungsm√∂glichkeiten gegen√ºber GitHub findest du unter: https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-privacy-statement#github-pages\nDu hast das Recht der Verarbeitung zu widersprechen. Ob der Widerspruch erfolgreich ist, ist im Rahmen einer Interessenabw√§gung zu ermitteln.\nDie Daten werden gel√∂scht, sobald der Zweck der Verarbeitung entf√§llt.\nDie Verarbeitung der unter diesem Abschnitt angegebenen Daten ist weder gesetzlich noch vertraglich vorgeschrieben. Die Funktionsf√§higkeit der Website ist ohne die Verarbeitung nicht gew√§hrleistet.\nGitHub hat Compliance-Ma√ünahmen f√ºr internationale Daten√ºbermittlungen umgesetzt. Diese gelten f√ºr alle weltweiten Aktivit√§ten, bei denen GitHub personenbezogene Daten von nat√ºrlichen Personen in der EU verarbeitet. Diese Ma√ünahmen basieren auf den EU-Standardvertragsklauseln (SCCs). Weitere Informationen findest du unter: https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-data-protection-addendum#attachment-1‚Äìthe-standard-contractual-clauses-processors"
  },
  {
    "objectID": "legal/datenschutz.html#betroffenenrechte-und-hinweise",
    "href": "legal/datenschutz.html#betroffenenrechte-und-hinweise",
    "title": "Datenschutzerkl√§rung",
    "section": "Betroffenenrechte und Hinweise",
    "text": "Betroffenenrechte und Hinweise\nAls betroffene Person haben Sie folgende Rechte nach der DSGVO:\n\nAuskunft (Art. 15 DSGVO) ‚Äì Sie k√∂nnen jederzeit eine Best√§tigung verlangen, ob personenbezogene Daten √ºber Sie verarbeitet werden.\nBerichtigung (Art. 16 DSGVO) ‚Äì Sie haben das Recht auf Berichtigung unrichtiger oder unvollst√§ndiger personenbezogener Daten.\nL√∂schung (Art. 17 DSGVO) ‚Äì Sie haben das Recht, die L√∂schung Ihrer Daten zu verlangen, wenn diese nicht mehr ben√∂tigt werden oder unrechtm√§√üig verarbeitet werden.\nEinschr√§nkung der Verarbeitung (Art. 18 DSGVO) ‚Äì Sie k√∂nnen in bestimmten F√§llen die Einschr√§nkung der Verarbeitung Ihrer personenbezogenen Daten verlangen.\nWiderspruch (Art. 21 DSGVO) ‚Äì Sie k√∂nnen der Verarbeitung Ihrer personenbezogenen Daten widersprechen, sofern sich die Verarbeitung auf ein berechtigtes Interesse st√ºtzt.\nDaten√ºbertragbarkeit (Art. 20 DSGVO) ‚Äì Sie haben das Recht, die von Ihnen bereitgestellten Daten in einem strukturierten, g√§ngigen und maschinenlesbaren Format zu erhalten.\nWiderruf der Einwilligung (Art. 21 DSGVO) ‚Äì Sie k√∂nnen die Einwilligung zur Verarbeitung Ihrer Daten jederzeit widerrufen.\nBeschwerderecht ‚Äì Sie haben das Recht, sich bei einer Aufsichtsbeh√∂rde √ºber die Verarbeitung zu beschweren. Eine Liste der entsprechenden Beh√∂rden finden Sie unter: https://www.bfdi.bund.de/DE/Infothek/Anschriften_Links/anschriften_links-node.html.\n\nHinweisen m√∂chten wir Sie zudem auf Folgendes:\n\nPflicht zur Bereitstellung von Daten ‚Äì Die Bereitstellung personenbezogener Daten ist zur Nutzung dieser Webseite nicht erforderlich. Sie m√ºssen keine personenbezogenen Daten angeben, um die Seite zu besuchen. Es ist jedoch m√∂glich, dass einige Daten (wie Server-Logs) automatisch erfasst werden, wenn Sie die Webseite besuchen.\nAutomatisierte Entscheidungsfindung/Profiling ‚Äì Auf dieser Webseite werden keine automatisierten Entscheidungen oder Profiling-Ma√ünahmen durchgef√ºhrt.\nVerweise auf externe Webseiten ‚Äì Diese Webseite enth√§lt Links zu externen Webseiten, auf deren Inhalt und Datenschutzpraktiken wir keinen Einfluss haben. F√ºr den Inhalt der verlinkten Seiten sind ausschlie√ülich deren Betreiber verantwortlich. Bitte beachten Sie, dass beim Anklicken eines externen Links personenbezogene Daten (wie Ihre IP-Adresse) an den Betreiber der externen Webseite √ºbermittelt werden k√∂nnen. Wir empfehlen, die Datenschutzerkl√§rungen der verlinkten Webseiten zu pr√ºfen."
  },
  {
    "objectID": "legal/datenschutz.html#einsatz-von-google-fonts",
    "href": "legal/datenschutz.html#einsatz-von-google-fonts",
    "title": "Datenschutzerkl√§rung",
    "section": "Einsatz von Google Fonts",
    "text": "Einsatz von Google Fonts\nDiese Seite nutzt zur einheitlichen Darstellung von Schriftarten so genannte Google Fonts, die von Google bereitgestellt werden. Beim Aufruf einer Seite l√§dt Ihr Browser die ben√∂tigten Fonts in ihren Browsercache, um Texte und Schriftarten korrekt anzuzeigen.\nZu diesem Zweck muss der von Ihnen verwendete Browser Verbindung zu den Servern von Google aufnehmen. Hierdurch erlangt Google Kenntnis dar√ºber, dass √ºber Ihre IP-Adresse diese Website aufgerufen wurde. Die Nutzung von Google Fonts erfolgt auf Grundlage von Art. 6 Abs. 1 lit. f DSGVO. Der Websitebetreiber hat ein berechtigtes Interesse an der einheitlichen Darstellung des Schriftbildes auf seiner Website. Sofern eine entsprechende Einwilligung abgefragt wurde, erfolgt die Verarbeitung ausschlie√ülich auf Grundlage von Art. 6 Abs. 1 lit. a DSGVO und ¬ß 25 Abs. 1 TDDDG, soweit die Einwilligung die Speicherung von Cookies oder den Zugriff auf Informationen im Endger√§t des Nutzers (z.B. Device-Fingerprinting) im Sinne des TDDDG umfasst. Die Einwilligung ist jederzeit widerrufbar.\nWenn Ihr Browser Google Fonts nicht unterst√ºtzt, wird eine Standardschrift von Ihrem Computer genutzt. Weitere Informationen zu Google Fonts finden Sie unter https://developers.google.com/fonts/faq und in der Datenschutzerkl√§rung von Google: https://policies.google.com/privacy?hl=de.\nDas Unternehmen verf√ºgt √ºber eine Zertifizierung nach dem ‚ÄûEU-US Data Privacy Framework‚Äú (DPF). Der DPF ist ein √úbereinkommen zwischen der Europ√§ischen Union und den USA, der die Einhaltung europ√§ischer Datenschutzstandards bei Datenverarbeitungen in den USA gew√§hrleisten soll. Jedes nach dem DPF zertifizierte Unternehmen verpflichtet sich, diese Datenschutzstandards einzuhalten. Weitere Informationen hierzu erhalten Sie vom Anbieter unter folgendem Link: https://www.dataprivacyframework.gov/participant/5780."
  }
]